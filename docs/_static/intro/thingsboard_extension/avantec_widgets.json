{
  "widgetsBundle": {
    "alias": "avantec_widgets",
    "title": "Avantec widgets",
    "image": null
  },
  "widgetTypes": [
    {
      "alias": "testattributescard",
      "name": "Simple Attributes Card",
      "descriptor": {
        "type": "latest",
        "sizeX": 7,
        "sizeY": 3,
        "resources": [],
        "templateHtml": "",
        "templateCss": "#container {\r\n    overflow: auto;\r\n}\r\n\r\n.tbDatasource-container {\r\n    margin: 4px;\r\n    padding: 1px;\r\n}\r\n\r\n.tbDatasource-title {\r\n    font-size: 1.200rem;\r\n    font-weight: 500;\r\n    padding-bottom: 10px;\r\n}\r\n\r\n.tbDatasource-table {\r\n    width: 100%;\r\n    box-shadow: 0 0 10px #ccc;\r\n    border-collapse: collapse;\r\n    white-space: nowrap;\r\n    font-size: 1.000rem;\r\n    color: #757575;\r\n}\r\n\r\n.tbDatasource-table td {\r\n    position: relative;\r\n    border-top: 1px solid rgba(0, 0, 0, 0.12);\r\n    border-bottom: 1px solid rgba(0, 0, 0, 0.12);\r\n    padding: 0px 9px;\r\n    box-sizing: border-box;\r\n}",
        "controllerScript": "// Based on Cards-->Attributes Card\r\n\r\nself.onInit = function() {\r\n    \r\n    //self.ctx.datasourceTitleCells = [];\r\n    self.ctx.valueCells = [];\r\n    self.ctx.labelCells = [];\r\n    \r\n    for (var i=0; i < self.ctx.datasources.length; i++) {\r\n        var tbDatasource = self.ctx.datasources[i];\r\n\r\n        var datasourceId = 'tbDatasource' + i;\r\n        self.ctx.$container.append(\r\n            \"<div id='\" + datasourceId +\r\n            \"' class='tbDatasource-container'></div>\"\r\n        );\r\n\r\n        var datasourceContainer = $('#' + datasourceId,\r\n            self.ctx.$container);\r\n\r\n        //datasourceContainer.append(\r\n        //    \"<div class='tbDatasource-title'>\" +\r\n        //    tbDatasource.name + \"</div>\"\r\n        //);\r\n        \r\n        //var datasourceTitleCell = $('.tbDatasource-title', datasourceContainer);\r\n        //self.ctx.datasourceTitleCells.push(datasourceTitleCell);\r\n        \r\n        var tableId = 'table' + i;\r\n        datasourceContainer.append(\r\n            \"<table id='\" + tableId +\r\n            \"' class='tbDatasource-table'><col width='30%'><col width='70%'></table>\"\r\n        );\r\n        var table = $('#' + tableId, self.ctx.$container);\r\n\r\n        for (var a = 0; a < tbDatasource.dataKeys.length; a++) {\r\n            var dataKey = tbDatasource.dataKeys[a];\r\n            var labelCellId = 'labelCell' + a;\r\n            var cellId = 'cell' + a;\r\n            table.append(\"<tr><td id='\" + labelCellId + \"'>\" + dataKey.label +\r\n                \"</td><td id='\" + cellId +\r\n                \"'></td></tr>\");\r\n            var labelCell = $('#' + labelCellId, table);\r\n            self.ctx.labelCells.push(labelCell);\r\n            var valueCell = $('#' + cellId, table);\r\n            self.ctx.valueCells.push(valueCell);\r\n        }\r\n    }    \r\n    \r\n    self.onResize();\r\n}\r\n\r\nself.onDataUpdated = function() {\r\n    for (var i = 0; i < self.ctx.valueCells.length; i++) {\r\n        var cellData = self.ctx.data[i];\r\n        if (cellData && cellData.data && cellData.data.length > 0) {\r\n            var tvPair = cellData.data[cellData.data.length -\r\n                1];\r\n            var value = tvPair[1];\r\n            var textValue;\r\n            //toDo -> + IsNumber\r\n            \r\n            if (isNumber(value)) {\r\n                var decimals = self.ctx.decimals;\r\n                var units = self.ctx.units;\r\n                if (cellData.dataKey.decimals || cellData.dataKey.decimals === 0) {\r\n                    decimals = cellData.dataKey.decimals;\r\n                }\r\n                if (cellData.dataKey.units) {\r\n                    units = cellData.dataKey.units;\r\n                }\r\n                txtValue = self.ctx.utils.formatValue(value, decimals, units, true);\r\n            } else {\r\n                txtValue = value;\r\n            }\r\n            self.ctx.valueCells[i].html(txtValue);\r\n        }\r\n    }\r\n    \r\n    function isNumber(n) {\r\n        return !isNaN(parseFloat(n)) && isFinite(n);\r\n    }\r\n}\r\n\r\nself.onResize = function() {\r\n    var datasourceTitleFontSize = self.ctx.height/8;\r\n    if (self.ctx.width/self.ctx.height <= 1.5) {\r\n        datasourceTitleFontSize = self.ctx.width/12;\r\n    }\r\n    datasourceTitleFontSize = Math.min(datasourceTitleFontSize, 20);\r\n    //for (var i = 0; i < self.ctx.datasourceTitleCells.length; i++) {\r\n    //    self.ctx.datasourceTitleCells[i].css('font-size', datasourceTitleFontSize+'px');\r\n    //}\r\n    var valueFontSize = self.ctx.height/9;\r\n    var labelFontSize = self.ctx.height/9;\r\n    if (self.ctx.width/self.ctx.height <= 1.5) {\r\n        valueFontSize = self.ctx.width/15;\r\n        labelFontSize = self.ctx.width/15;\r\n    }\r\n    valueFontSize = Math.min(valueFontSize, 18);\r\n    labelFontSize = Math.min(labelFontSize, 18);\r\n\r\n    for (i = 0; i < self.ctx.valueCells; i++) {\r\n        self.ctx.valueCells[i].css('font-size', valueFontSize+'px');\r\n        self.ctx.valueCells[i].css('height', valueFontSize*2.5+'px');\r\n        self.ctx.valueCells[i].css('padding', '0px ' + valueFontSize*0.5 + 'px');\r\n        self.ctx.labelCells[i].css('font-size', labelFontSize+'px');\r\n        self.ctx.labelCells[i].css('height', labelFontSize*2.5+'px');\r\n        self.ctx.labelCells[i].css('padding', '0px ' + labelFontSize*0.5 + 'px');\r\n    }    \r\n}\r\n\r\nself.onDestroy = function() {\r\n}\r\n\r\nself.typeParameters = function() {\r\n    return {\r\n        maxDatasources: 1, // Maximum allowed datasources for this widget, -1 - unlimited\r\n        maxDataKeys: -1 //Maximum allowed data keys for this widget, -1 - unlimited\r\n    };\r\n}\r\n",
        "settingsSchema": "{}",
        "dataKeySettingsSchema": "{}\n",
        "defaultConfig": "{\"datasources\":[{\"type\":\"function\",\"name\":\"function\",\"dataKeys\":[{\"name\":\"f(x)\",\"type\":\"function\",\"label\":\"Random\",\"color\":\"#2196f3\",\"settings\":{},\"_hash\":0.15479322438769105,\"funcBody\":\"var value = prevValue + Math.random() * 100 - 50;\\nvar multiplier = Math.pow(10, 2 || 0);\\nvar value = Math.round(value * multiplier) / multiplier;\\nif (value < -1000) {\\n\\tvalue = -1000;\\n} else if (value > 1000) {\\n\\tvalue = 1000;\\n}\\nreturn value;\"},{\"name\":\"f(x)\",\"type\":\"function\",\"label\":\"Cos\",\"color\":\"#4caf50\",\"settings\":{},\"_hash\":0.5242256504485792,\"funcBody\":\"return Math.round(1000*Math.cos(time/5000));\"},{\"name\":\"f(x)\",\"type\":\"function\",\"label\":\"Sin\",\"color\":\"#f44336\",\"settings\":{},\"_hash\":0.5818890099680771,\"funcBody\":\"return Math.round(1000*Math.sin(time/5000));\"}]}],\"timewindow\":{\"realtime\":{\"timewindowMs\":60000}},\"showTitle\":true,\"backgroundColor\":\"#fff\",\"color\":\"rgba(0, 0, 0, 0.87)\",\"padding\":\"8px\",\"settings\":{},\"title\":\"Simple Attributes Card\",\"showTitleIcon\":false,\"titleIcon\":\"more_horiz\",\"iconColor\":\"rgba(0, 0, 0, 0.87)\",\"iconSize\":\"24px\",\"titleTooltip\":\"\",\"dropShadow\":true,\"enableFullscreen\":true,\"widgetStyle\":{},\"titleStyle\":{\"fontSize\":\"16px\",\"fontWeight\":400},\"useDashboardTimewindow\":true,\"displayTimewindow\":true,\"showLegend\":false,\"actions\":{}}"
      }
    },
    {
      "alias": "styled_button_of_string_value",
      "name": "Styled button of string value",
      "descriptor": {
        "type": "rpc",
        "sizeX": 7.5,
        "sizeY": 3,
        "resources": [],
        "templateHtml": "<div class=\"tb-rpc-button\" fxLayout=\"column\">\r\n    <div fxFlex=\"{{showTitle ? 20 : 0}}\" class=\"title-container\" fxLayout=\"row\"\r\n        fxLayoutAlign=\"center center\" [fxShow]=\"showTitle\">\r\n        <span class=\"button-title\">{{title}}</span>\r\n    </div>\r\n    <div fxFlex=\"{{showTitle ? 80 : 100}}\" [ngStyle]=\"{paddingTop: showTitle ? '5px': '5px'}\"\r\n        class=\"button-container\" fxLayout=\"column\" fxLayoutAlign=\"center center\">\r\n            <button mat-button (click)=\"updateValue(buttonState?.on.value===currentValue)\" \r\n                [class.mat-raised-button]=\"buttonState?.on.value===currentValue ? buttonState?.on.isRaised : buttonState?.off.isRaised\"\r\n                [color]=\"(buttonState?.on.value===currentValue ? buttonState?.on.isPrimary : buttonState?.off.isPrimary) ? 'primary' : ''\" \r\n                [ngStyle]=\"buttonState?.on.value===currentValue ? customOnStyle : customOffStyle\">\r\n                {{buttonState?.on.value===currentValue ? buttonState?.on.label : buttonState?.off.label}}\r\n            </button>\r\n\r\n    </div>\r\n    <div class=\"error-container\" [ngStyle]=\"{'background': error?.length ? 'rgba(255,255,255,0.25)' : 'none'}\"\r\n         fxLayout=\"row\" fxLayoutAlign=\"center center\">\r\n        <span class=\"button-error\">{{ error }}</span>\r\n    </div>\r\n</div>",
        "templateCss": ".tb-rpc-button {\n    width: 100%;\n    height: 100%;\n}\n\n.tb-rpc-button .title-container {\n    font-weight: 500;\n    white-space: nowrap;\n    margin: 10px 0;\n}\n\n.tb-rpc-button .button-container div{\n    min-width: 80%\n}\n\n.tb-rpc-button .button-container .mat-button{\n    width: 100%;\n    margin: 0;\n}\n\n.tb-rpc-button .button-container .mat-button{\n    padding: 0 4px;\n}\n\n.tb-rpc-button .error-container {\n    position: absolute;\n    top: 2%;\n    right: 0;\n    left: 0;\n    z-index: 4;\n    height: 14px;\n}\n\n.tb-rpc-button .error-container .button-error {\n    color: #ff3315;\n    white-space: nowrap;\n}",
        "controllerScript": "let valueSubscription;\r\n\r\nself.onInit = function() {\r\n    self.ctx.ngZone.run(function() {\r\n       init();\r\n       self.ctx.detectChanges(true);\r\n    });\r\n};\r\n\r\nfunction init() {\r\n    let utils       = self.ctx.$scope.$injector.get(self.ctx.servicesMap.get('utils'));\r\n    //let types       = self.ctx.$scope.$injector.get(self.ctx.servicesMap.get('types'));\r\n    //let toast       = self.ctx.$scope.$injector.get(self.ctx.servicesMap.get('toast'));\r\n    let translate   = self.ctx.$scope.$injector.get(self.ctx.servicesMap.get('translate'));\r\n    //let $q          = self.ctx.$scope.$injector.get(self.ctx.servicesMap.get('$q'));\r\n    let http        = self.ctx.$scope.$injector.get(self.ctx.servicesMap.get('http'));\r\n    let attributeService = self.ctx.$scope.$injector.get(self.ctx.servicesMap.get('attributeService'));\r\n    let rpcUpdateStatus = {};\r\n    let settings = utils.deepClone(self.ctx.settings) || {}; \r\n    \r\n    self.ctx.$scope.toastTargetId = 'input-widget' + utils.guid();\r\n    self.ctx.$scope.showTitle = settings.title && settings.title.length ? true : false; ////utils.defaultValue(settings.title, true);\r\n    self.ctx.$scope.title = settings.title;\r\n    self.ctx.$scope.buttonState = settings.buttonState;\r\n    if (settings.buttonState.on.isPrimary === false) {\r\n            self.ctx.$scope.customOnStyle = {\r\n                'background-color': self.ctx.$scope.buttonState.on.bgColor,\r\n                'color': self.ctx.$scope.buttonState.on.textColor,\r\n            };\r\n    }\r\n    if (settings.buttonState.off.isPrimary === false) {\r\n            self.ctx.$scope.customOffStyle = {\r\n                'background-color': self.ctx.$scope.buttonState.off.bgColor,\r\n                'color': self.ctx.$scope.buttonState.off.textColor,\r\n            };\r\n    }\r\n    \r\n    //console.log(\"onInit\", settings);\r\n    \r\n    function parseValue(data) {\r\n        var parsed = data;\r\n        if (typeof settings.buttonState.on.value === \"string\") {\r\n            if (typeof data === \"boolean\") {\r\n                //parsed = data===true ? \"true\" : \"false\";\r\n                parsed = data===true ? settings.buttonState.on.value : settings.buttonState.off.value;\r\n                \r\n            } else if (typeof data === \"number\") {\r\n                //parsed = data===1 ? \"true\" : \"false\";\r\n                parsed = data!==0 ? settings.buttonState.on.value : settings.buttonState.off.value;\r\n                \r\n            }\r\n        } else if (typeof settings.buttonState.on.value === \"boolean\") {\r\n            if (typeof data === \"string\") {\r\n                parsed = data===\"true\" ? true : false;\r\n            } else if (typeof data === \"number\") {\r\n                parsed = data!==0 ? true : false;\r\n            }\r\n        }\r\n        return parsed;\r\n    }\r\n    let parseValueFunction = parseValue; //(data) => data;  // Retrieve data\r\n    if (settings.parseValueFunction && settings.parseValueFunction.length) {\r\n        try {\r\n            parseValueFunction = new Function('data', settings.parseValueFunction);\r\n        } catch (e) {\r\n            parseValueFunction = parseValue; //(data) => data;\r\n        }\r\n    }\r\n    \r\n    let convertValueFunction = (value) => value;    // Update data\r\n    if (settings.convertValueFunction && settings.convertValueFunction.length) {\r\n        try {\r\n            convertValueFunction = new Function('value', settings.convertValueFunction);\r\n        } catch (e) {\r\n            convertValueFunction = (value) => value;\r\n        }\r\n    }\r\n\r\n    // subscribe attribute & timeseries \r\n    function onDataUpdatedForSubscribe(subscription, apply) {\r\n        if (subscription.data.length) {\r\n            var keyData = subscription.data[0];\r\n            if (keyData && keyData.data && keyData.data[0]) {\r\n                var attrValue = keyData.data[0][1];\r\n                if (attrValue) {\r\n                    try {\r\n                        self.ctx.$scope.currentValue = self.ctx.$scope.originalValue = parseValueFunction(attrValue);  ////angular.fromJson(attrValue)\r\n                    } catch (e){\r\n                        self.ctx.$scope.error = 'parseValueFunction(value) error!';\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        \r\n        if (apply) {\r\n            self.ctx.detectChanges(); //self.ctx.$scope.$digest();\r\n        }\r\n    }\r\n    function onDataUpdateErrorForSubscribe(subscription, e) {\r\n        var exceptionData = utils.parseException(e);\r\n        var errorText = exceptionData.name;\r\n        if (exceptionData.message) {\r\n            errorText += ': ' + exceptionData.message;\r\n        }\r\n        self.ctx.$scope.error = errorText;\r\n    }\r\n    function subscribeAttributesOrTimeseries(type, entityType, entityId, retrieveMethod, key) {\r\n        var valueSubscriptionInfo = [{\r\n            type:       type,\r\n            entityType: entityType,\r\n            entityId:   entityId\r\n        }];\r\n        \r\n        if (retrieveMethod == 'attribute') {\r\n            valueSubscriptionInfo[0].attributes = [\r\n                {name: key}\r\n            ];\r\n        } else {\r\n            valueSubscriptionInfo[0].timeseries = [\r\n                {name: key}\r\n            ];\r\n        }\r\n        \r\n        var subscriptionOptions = {\r\n            callbacks: {\r\n                onDataUpdated: onDataUpdatedForSubscribe,\r\n                onDataUpdateError: onDataUpdateErrorForSubscribe\r\n            }\r\n        };\r\n        self.ctx.subscriptionApi.createSubscriptionFromInfo (\r\n            'latest', valueSubscriptionInfo, subscriptionOptions, false, true).subscribe( //types.widgetType.latest.value\r\n            (subscription) => {\r\n                valueSubscription = subscription;\r\n            }\r\n        );    \r\n    }\r\n    \r\n    // update attribute\r\n    function updateAttributes(entityType, entityId, attributeScope, key, value) { \r\n        let attributes = [];\r\n        attributes.push({\r\n            \"key\": key,                             // attribute name,\r\n            \"value\": value    // attribute value\r\n        });\r\n\r\n        ////attributeService.saveEntityAttributes(self.ctx.datasources[0].entityType, self.ctx.datasources[0].entityId,\r\n        attributeService.saveEntityAttributes({\"entityType\":entityType, \"id\":entityId}, \r\n            attributeScope, attributes).subscribe(\r\n            function success() {\r\n                retrieveValue();  //self.ctx.$scope.originalValue = self.ctx.$scope.currentValue = value;\r\n                self.ctx.$scope.error = \"\";\r\n            },\r\n            function fail(rejection) {\r\n                if (settings.showError) {\r\n                    self.ctx.$scope.error =\r\n                        rejection.status + \": \" +\r\n                        rejection.statusText;\r\n                }\r\n            }\r\n        );\r\n    }\r\n    \r\n    // update timeseries \r\n    function saveEntityTimeseries(entityType, entityId, telemetries) {\r\n        var telemetriesData = {};\r\n        for (var a = 0; a < telemetries.length; a++) {\r\n            if (typeof telemetries[a].value !== 'undefined' && telemetries[a].value !== null) {\r\n                telemetriesData[telemetries[a].key] = telemetries[a].value;\r\n            }\r\n        }\r\n        if (Object.keys(telemetriesData).length) {\r\n            var url = '/api/plugins/telemetry/' + entityType + '/' + entityId + '/timeseries/scope';\r\n            return http.post(url, telemetriesData);\r\n        }\r\n        return null;\r\n    }\r\n    function updateTimeseries(entityType, entityId, key, value) {\r\n        //var datasource = self.ctx.datasources[0];\r\n        let observable = saveEntityTimeseries(\r\n            entityType,     // datasource.entityType,\r\n            entityId,       // datasource.entityId,\r\n            [\r\n                {\r\n                    key: key,\r\n                    value: value\r\n                }\r\n            ]\r\n        );\r\n        if (observable) {\r\n            observable.subscribe(\r\n                function success() {\r\n                    /*if (settings.showResultMessage) {\r\n                        $scope.showSuccessToast(translate.instant('widgets.input-widgets.update-successful'), 1000, 'bottom', 'left', $scope.toastTargetId);\r\n                    }*/\r\n                    retrieveValue();    //$scope.originalValue = $scope.attributeUpdateFormGroup.get('currentValue').value;\r\n                },\r\n                function fail() {\r\n                    /*if (settings.showResultMessage) {\r\n                        $scope.showErrorToast(translate.instant('widgets.input-widgets.update-failed'), 'bottom', 'left', $scope.toastTargetId);\r\n                    }*/\r\n                    self.ctx.$scope.error = translate.instant('widgets.input-widgets.update-failed');\r\n                }\r\n            );\r\n        }\r\n    }\r\n\r\n    // RPC retrieve value\r\n    function rpcRetrieveValue(method, timeout) {\r\n        if (method && method.length) {\r\n            self.ctx.$scope.error = '';\r\n            self.ctx.controlApi.sendTwoWayCommand(method, null, timeout).subscribe(\r\n                function success(responseBody) {\r\n                    ////self.ctx.$scope.currentValue = self.ctx.$scope.originalValue = responseBody;\r\n                    self.ctx.$scope.currentValue = self.ctx.$scope.originalValue = parseValueFunction(responseBody);\r\n\r\n                    ////self.ctx.$scope.$digest(); // Error: $digest already in progress\r\n                },\r\n                function fail() {\r\n                    self.ctx.$scope.error = self.ctx.defaultSubscription.rpcErrorText;\r\n                }\r\n            );\r\n        } else {\r\n            self.ctx.$scope.error = \"retrieveRPCMethod is null.\";\r\n        }\r\n    }\r\n    // RPC update value\r\n    function rpcUpdateValue(method, value, timeout) {\r\n        if (rpcUpdateStatus.executingUpdateValue) {\r\n            rpcUpdateStatus.scheduledValue = value;\r\n            return;\r\n        } else {\r\n            rpcUpdateStatus.scheduledValue = null;\r\n            rpcUpdateStatus.rpcValue = value;\r\n            rpcUpdateStatus.executingUpdateValue = true;\r\n        }\r\n        self.ctx.$scope.error = '';\r\n        self.ctx.controlApi.sendOneWayCommand(method, value, timeout).subscribe(\r\n            () => {\r\n                rpcUpdateStatus.executingUpdateValue = false;\r\n                if (rpcUpdateStatus.scheduledValue !== null && rpcUpdateStatus.scheduledValue != rpcUpdateStatus.rpcValue) {\r\n                    rpcUpdateValue(rpcUpdateStatus.scheduledValue);\r\n                } else {\r\n                    retrieveValue(); // self.ctx.$scope.originalValue = self.ctx.$scope.currentValue = value;\r\n                }\r\n            },\r\n            () => {\r\n                rpcUpdateStatus.executingUpdateValue = false;\r\n                self.ctx.$scope.error = self.ctx.defaultSubscription.rpcErrorText;\r\n            }\r\n        );\r\n    }\r\n\r\n    // update value\r\n    self.ctx.$scope.updateValue = function(on_off) {\r\n        //console.log(\"updateValue()\", settings);\r\n        \r\n        let value = on_off ? settings.buttonState.off.value : \r\n            settings.buttonState.on.value;\r\n        let converted = convertValueFunction(value);\r\n        \r\n        if (settings.updateMethod === \"SHARED_SCOPE\" || settings.updateMethod === \"SERVER_SCOPE\") {\r\n            updateAttributes(\"DEVICE\", //types.entityType.device, \r\n                self.ctx.defaultSubscription.targetDeviceId, \r\n                settings.updateMethod, \r\n                settings.updateAttributeKey, \r\n                converted);\r\n                \r\n        } else if (settings.updateMethod === \"timeseries\") {\r\n            updateTimeseries(\"DEVICE\", // types.entityType.device,  types.constant.js\r\n                self.ctx.defaultSubscription.targetDeviceId, \r\n                settings.updateAttributeKey, \r\n                converted);\r\n                \r\n        } else if (settings.updateMethod === \"rpc\") {\r\n            rpcUpdateValue(settings.updateRPCMethod, \r\n                converted, \r\n                settings.requestTimeout);\r\n            \r\n        } else {\r\n            self.ctx.$scope.error = \"updateMethod is error!\";\r\n\r\n        }\r\n    }\r\n\r\n    // retrieve value\r\n    var firstRetrieveValue = true;\r\n    function retrieveValue() {\r\n        let rpcEnabled = self.ctx.defaultSubscription.rpcEnabled;\r\n        let isSimulated = self.ctx.$scope.widgetEditMode;\r\n        if (!rpcEnabled) {\r\n            self.ctx.$scope.error = 'Target device is not set!';\r\n        } else {\r\n            if (!isSimulated) {\r\n                if (settings.retrieveMethod == 'rpc') {\r\n                    rpcRetrieveValue(settings.retrieveRPCMethod, settings.requestTimeout);\r\n                } else if (settings.retrieveMethod == 'attribute' || settings.retrieveMethod == 'timeseries') {\r\n                    if (firstRetrieveValue) {\r\n                        subscribeAttributesOrTimeseries(\"entity\", // types.datasourceType.entity, in types.constant.js\r\n                            \"DEVICE\", //types.entityType.device, in types.constant.js\r\n                            self.ctx.defaultSubscription.targetDeviceId, \r\n                            settings.retrieveMethod, \r\n                            settings.retrieveAttributeKey);\r\n                    }\r\n                }\r\n            } \r\n        }\r\n        \r\n        firstRetrieveValue = false;\r\n    }\r\n    \r\n    retrieveValue();\r\n};\r\n\r\nself.onResize = function() {\r\n};\r\n\r\nself.onDestory = function() {\r\n    if (valueSubscription) {\r\n        self.ctx.subscriptionApi.removeSubscription(valueSubscription.id);\r\n    }\r\n};\r\n\r\n/*self.onDataUpdated = function() {\r\n    try{\r\n        self.ctx.$scope.currentValue = self.ctx.$scope.originalValue = self.ctx.data[0].data[0][1];\r\n        self.ctx.$scope.$digest();\r\n    } catch (e) {\r\n        console.log(e);\r\n    }\r\n}*/\r\n\r\n/*self.typeParameters = function() {\r\n    return {\r\n        maxDatasources: 1, // Maximum allowed datasources for this widget, -1 - unlimited\r\n        maxDataKeys: 1 //Maximum allowed data keys for this widget, -1 - unlimited\r\n    }\r\n};*/\r\n",
        "settingsSchema": "{\n    \"schema\": {\n        \"type\": \"object\",\n        \"title\": \"Settings\",\n        \"properties\": {\n            \"title\": {\n                \"title\": \"Widget title\",\n                \"type\": \"string\",\n                \"default\": \"\"\n            },\n            \n            \"retrieveMethod\": {\n                \"title\": \"Retrieve string value using method\",\n                \"type\": \"string\",\n                \"default\": \"rpc\"\n            },\n            \"retrieveAttributeKey\": {\n                \"title\": \"Retrieve Attribute/Timeseries value key (only when subscribe for attribute/timeseries method)\",\n                \"type\": \"string\",\n                \"default\": \"\"\n            },\n            \"retrieveRPCMethod\": {\n                \"title\": \"Retrieve value using RPC method (only when call RPC get value method)\",\n                \"type\": \"string\",\n                \"default\": \"\"\n            },\n            \"parseValueFunction\": {\n                \"title\": \"Parse value function, f(data), returns string\",\n                \"type\": \"string\",\n                \"default\": \"\"\n            },\n            \n            \"updateMethod\": {\n                \"title\": \"Update string value using method\",\n                \"type\": \"string\",\n                \"default\": \"rpc\"\n            },\n            \"updateAttributeKey\": {\n                \"title\": \"Update Attribute/Timeseries value key (only when update for attribute/timeseries method)\",\n                \"type\": \"string\",\n                \"default\": \"\"\n            },\n            \"updateRPCMethod\": {\n                \"title\": \"Update value using RPC method (only when call RPC set value method)\",\n                \"type\": \"string\",\n                \"default\": \"\"\n            },\n            \"convertValueFunction\": {\n                \"title\": \"Convert value function, f(value), returns payload used by RPC set value method\",\n                \"type\": \"string\",\n                \"default\": \"\"\n            },\n\n            \"requestTimeout\": {\n                \"title\": \"RPC request timeout\",\n                \"type\": \"number\",\n                \"default\": 5000\n            },\n            \n            \"buttonState\":{\n                \"type\": \"object\",\n                \"title\": \"Button state\",\n                \"properties\": {\n                    \"on\": {\n                        \"type\": \"object\",\n                        \"title\": \"On state\",\n                        \"properties\": {\n                            \"value\": {\n                                \"title\": \"On state attribute value\",\n                                \"type\": \"string\",\n                                \"default\": \"true\",\n                                \"description\": \"On state attribute value.\"\n                            },\n                            \"label\": {\n                                \"title\": \"On state label\",\n                                \"type\": \"string\",\n                                \"default\": \"On state Label\"\n                            },\n                            \"isRaised\": {\n                                \"type\": \"boolean\",\n                                \"title\": \"Raised\",\n                                \"default\": true\n                            },\n                            \"isPrimary\": {\n                                \"type\": \"boolean\",\n                                \"title\": \"Primary color\",\n                                \"default\": true\n                            },\n                            \"bgColor\": {\n                                \"type\": \"string\",\n                                \"title\": \"On state background color\",\n                                \"default\": null\n                            },\n                            \"textColor\": {\n                                \"type\": \"string\",\n                                \"title\": \"On state text color\",\n                                \"default\": null\n                            }\n                        }, \n                        \"required\": [\n                            \"value\",\n                            \"label\"\n                        ]\n                    },\n                    \"off\": {\n                        \"type\": \"object\",\n                        \"title\": \"Off state\",\n                        \"properties\": {\n                            \"value\": {\n                                \"title\": \"Off state attribute value\",\n                                \"type\": \"string\",\n                                \"default\": \"false\",\n                                \"description\": \"Off state attribute value.\"\n                            },\n                            \"label\": {\n                                \"title\": \"Off state label\",\n                                \"type\": \"string\",\n                                \"default\": \"Off state label\"\n                            },\n                            \"isRaised\": {\n                                \"type\": \"boolean\",\n                                \"title\": \"Raised\",\n                                \"default\": true\n                            },\n                            \"isPrimary\": {\n                                \"type\": \"boolean\",\n                                \"title\": \"Primary color\",\n                                \"default\": false\n                            },\n                            \"bgColor\": {\n                                \"type\": \"string\",\n                                \"title\": \"Off state background color\",\n                                \"default\": null\n                            },\n                            \"textColor\": {\n                                \"type\": \"string\",\n                                \"title\": \"Off state text color\",\n                                \"default\": null\n                            }\n                        }, \n                        \"required\": [\n                            \"value\",\n                            \"label\"\n                        ]\n                    }\n                }, \n                \"required\": [\n                    \"on\",\n                    \"off\"\n                ]\n            },\n            \n            \"required\": [\n                \"retrieveMethod\",\n                \"updateMethod\",\n                \"requestTimeout\",\n                \"buttonState\"\n            ]\n        }\n    },\n    \"form\": [\n        \"title\",\n\n        {\n            \"key\": \"retrieveMethod\",\n            \"type\": \"rc-select\",\n            \"multiple\": false,\n            \"items\": [\n                {\n                    \"value\": \"none\",\n                    \"label\": \"Don't retrieve\"\n                },\n                {\n                    \"value\": \"attribute\",\n                    \"label\": \"Subscribe for attribute\"\n                },\n                {\n                    \"value\": \"timeseries\",\n                    \"label\": \"Subscribe for timeseries\"\n                },\n                {\n                    \"value\": \"rpc\",\n                    \"label\": \"Call RPC get value method\"\n                }\n            ]\n        },\n        \"retrieveAttributeKey\",\n        \"retrieveRPCMethod\",\n        {\n            \"key\": \"parseValueFunction\",\n            \"type\": \"javascript\"\n        },\n        \n        {\n            \"key\": \"updateMethod\",\n            \"type\": \"rc-select\",\n            \"multiple\": false,\n            \"items\": [\n                {\n                    \"value\": \"SHARED_SCOPE\",\n                    \"label\": \"Update shared attribute\"\n                },\n                {\n                    \"value\": \"SERVER_SCOPE\",\n                    \"label\": \"Update server attribute\"\n                },\n                {\n                    \"value\": \"timeseries\",\n                    \"label\": \"Update timeseries\"\n                },\n                {\n                    \"value\": \"rpc\",\n                    \"label\": \"Call RPC set value method\"\n                }\n            ]\n        },\n        \"updateAttributeKey\",\n        \"updateRPCMethod\",\n        {\n            \"key\": \"convertValueFunction\",\n            \"type\": \"javascript\"\n        },\n        \n        \"requestTimeout\",\n        \n        {\n            \"key\": \"buttonState\",\n            \"items\" :[\n                {\n                    \"key\": \"buttonState.on\",\n                    \"items\": [\n                        \"buttonState.on.value\",\n                        \"buttonState.on.label\",\n                        \"buttonState.on.isRaised\",\n                        \"buttonState.on.isPrimary\",\n                        {\n                            \"key\": \"buttonState.on.bgColor\",\n                            \"type\": \"color\"\n                        }, {\n                            \"key\": \"buttonState.on.textColor\",\n                            \"type\": \"color\"\n                        }\n                    ]\n                }, {\n                    \"key\": \"buttonState.off\",\n                    \"items\": [\n                        \"buttonState.off.value\",\n                        \"buttonState.off.label\",\n                        \"buttonState.off.isRaised\",\n                        \"buttonState.off.isPrimary\",\n                        {\n                            \"key\": \"buttonState.off.bgColor\",\n                            \"type\": \"color\"\n                        }, {\n                            \"key\": \"buttonState.off.textColor\",\n                            \"type\": \"color\"\n                        }\n                    ]\n                }\n            ]\n        }\n    ]\n}",
        "dataKeySettingsSchema": "{}\r\n",
        "defaultConfig": "{\"showTitle\":true,\"backgroundColor\":\"#e6e7e8\",\"color\":\"rgba(0, 0, 0, 0.87)\",\"padding\":\"8px\",\"settings\":{\"retrieveMethod\":\"rpc\",\"retrieveAttributeKey\":\"value\",\"retrieveRPCMethod\":\"getValue\",\"updateMethod\":\"rpc\",\"updateAttributeKey\":\"value\",\"updateRPCMethod\":\"setValue\",\"requestTimeout\":5000,\"buttonState\":{\"on\":{\"value\":\"true\",\"label\":\"On state Label\",\"isRaised\":true,\"isPrimary\":true},\"off\":{\"value\":\"false\",\"label\":\"Off state label\",\"isRaised\":true}}},\"title\":\"Styled button of string value\",\"showTitleIcon\":false,\"titleIcon\":\"more_horiz\",\"iconColor\":\"rgba(0, 0, 0, 0.87)\",\"iconSize\":\"24px\",\"titleTooltip\":\"\",\"dropShadow\":true,\"enableFullscreen\":false,\"widgetStyle\":{},\"titleStyle\":{\"fontSize\":\"16px\",\"fontWeight\":400},\"useDashboardTimewindow\":true,\"displayTimewindow\":true,\"showLegend\":false,\"actions\":{},\"targetDeviceAliases\":[]}"
      }
    },
    {
      "alias": "segmented_switch_from_string_attribute_send_rpc",
      "name": "Segmented switch of string value",
      "descriptor": {
        "type": "rpc",
        "sizeX": 7.5,
        "sizeY": 3,
        "resources": [],
        "templateHtml": "<div class=\"tb-rpc-button\" fxLayout=\"column\">\r\n    <div fxFlex=\"{{showTitle ? 20 : 0}}\" class=\"title-container\" fxLayout=\"row\"\r\n        fxLayoutAlign=\"center center\" [fxShow]=\"showTitle\">\r\n        <span class=\"button-title\">{{title}}</span>\r\n    </div>\r\n    <div fxFlex=\"{{showTitle ? 80 : 100}}\" [ngStyle]=\"{paddingTop: showTitle ? '5px': '5px'}\"\r\n        class=\"button-container\" fxLayout=\"{{optionStyle?.orientation}}\" fxLayoutAlign=\"center center\"> \r\n            <button mat-button *ngFor=\"let x of options\" (click)=\"updateValue(x)\" \r\n                [class.mat-raised-button]=\"optionStyle?.isRaised\" \r\n                [color]=\"(x.attributeValue===currentValue ? optionStyle?.checkedOption.isPrimary : optionStyle?.uncheckedOption.isPrimary) ? 'primary' : ''\" \r\n                [ngStyle]=\"x.attributeValue===currentValue ? customCheckedStyle : customUncheckedStyle\">\r\n                {{x?.optionLabel}}\r\n            </button>\r\n\r\n    </div>\r\n    <div class=\"error-container\" [ngStyle]=\"{'background': error?.length ? 'rgba(255,255,255,0.25)' : 'none'}\"\r\n         fxLayout=\"row\" fxLayoutAlign=\"center center\">\r\n        <span class=\"button-error\">{{ error }}</span>\r\n    </div>\r\n</div>\r\n",
        "templateCss": ".tb-rpc-button {\n    width: 100%;\n    height: 100%;\n}\n\n.tb-rpc-button .title-container {\n    font-weight: 500;\n    white-space: nowrap;\n    margin: 10px 0;\n}\n\n.tb-rpc-button .button-container div{\n    min-width: 80%\n}\n\n.tb-rpc-button .button-container .mat-button{\n    width: 100%;\n    margin: 0;\n}\n\n.tb-rpc-button .button-container .mat-button{\n    padding: 0 4px;\n}\n\n.tb-rpc-button .error-container {\n    position: absolute;\n    top: 2%;\n    right: 0;\n    left: 0;\n    z-index: 4;\n    height: 14px;\n}\n\n.tb-rpc-button .error-container .button-error {\n    color: #ff3315;\n    white-space: nowrap;\n}",
        "controllerScript": "let valueSubscription;\r\n\r\nself.onInit = function() {\r\n    self.ctx.ngZone.run(function() {\r\n       init();\r\n       self.ctx.detectChanges(true);\r\n    });\r\n};\r\n\r\nfunction init() {\r\n    let utils       = self.ctx.$scope.$injector.get(self.ctx.servicesMap.get('utils'));\r\n    //let types       = self.ctx.$scope.$injector.get(self.ctx.servicesMap.get('types'));\r\n    //let toast       = self.ctx.$scope.$injector.get(self.ctx.servicesMap.get('toast'));\r\n    let translate   = self.ctx.$scope.$injector.get(self.ctx.servicesMap.get('translate'));\r\n    //let $q          = self.ctx.$scope.$injector.get(self.ctx.servicesMap.get('$q'));\r\n    let http        = self.ctx.$scope.$injector.get(self.ctx.servicesMap.get('http'));\r\n    let attributeService = self.ctx.$scope.$injector.get(self.ctx.servicesMap.get('attributeService'));\r\n    let rpcUpdateStatus = {};\r\n    let settings = utils.deepClone(self.ctx.settings) || {}; \r\n    \r\n    self.ctx.$scope.toastTargetId = 'input-widget' + utils.guid();\r\n    self.ctx.$scope.showTitle = settings.title && settings.title.length ? true : false; ////utils.defaultValue(settings.title, true);\r\n    self.ctx.$scope.title = settings.title;\r\n    self.ctx.$scope.options = settings.options;\r\n    self.ctx.$scope.optionStyle = settings.optionStyle;\r\n\r\n    self.ctx.$scope.customCheckedStyle = {};\r\n    self.ctx.$scope.customCheckedStyle['min-width'] = '40px';\r\n    self.ctx.$scope.customCheckedStyle['padding']   = '0 2px';\r\n    if (self.ctx.settings.optionStyle.orientation === 'column') {\r\n        self.ctx.$scope.customCheckedStyle['width']     = '100%';\r\n        self.ctx.$scope.customCheckedStyle['margin']    = 0;\r\n    } else {\r\n        self.ctx.$scope.customCheckedStyle['width']     = 100/self.ctx.settings.options.length + '%';\r\n        self.ctx.$scope.customCheckedStyle['margin']    = 0;\r\n    }\r\n    if (self.ctx.settings.optionStyle.checkedOption.isPrimary === false) {\r\n        self.ctx.$scope.customCheckedStyle['background-color']  = self.ctx.$scope.optionStyle.checkedOption.bgColor;\r\n        self.ctx.$scope.customCheckedStyle['color']             = self.ctx.$scope.optionStyle.checkedOption.textColor;\r\n    }\r\n\r\n    self.ctx.$scope.customUncheckedStyle = {};\r\n    self.ctx.$scope.customUncheckedStyle['min-width'] = '40px';\r\n    self.ctx.$scope.customUncheckedStyle['padding']   = '0 2px';\r\n    if (self.ctx.settings.optionStyle.orientation === \"column\") {\r\n        self.ctx.$scope.customUncheckedStyle['width']     = '100%';\r\n        self.ctx.$scope.customUncheckedStyle['margin']    = 0;\r\n    } else {\r\n        self.ctx.$scope.customUncheckedStyle['width']     = 100/self.ctx.settings.options.length + '%';\r\n        self.ctx.$scope.customUncheckedStyle['margin']    = 0;\r\n    }\r\n    if (self.ctx.settings.optionStyle.uncheckedOption.isPrimary === false) {\r\n        self.ctx.$scope.customUncheckedStyle['background-color']  = self.ctx.$scope.optionStyle.uncheckedOption.bgColor;\r\n        self.ctx.$scope.customUncheckedStyle['color']             = self.ctx.$scope.optionStyle.uncheckedOption.textColor;\r\n    }\r\n    \r\n    \r\n    //console.log(\"onInit\", settings);\r\n    \r\n    let parseValueFunction = (data) => data;        // Retrieve data\r\n    if (settings.parseValueFunction && settings.parseValueFunction.length) {\r\n        try {\r\n            parseValueFunction = new Function('data', settings.parseValueFunction);\r\n        } catch (e) {\r\n            parseValueFunction = (data) => data;\r\n        }\r\n    }\r\n    \r\n    let convertValueFunction = (value) => value;    // Update data\r\n    if (settings.convertValueFunction && settings.convertValueFunction.length) {\r\n        try {\r\n            convertValueFunction = new Function('value', settings.convertValueFunction);\r\n        } catch (e) {\r\n            convertValueFunction = (value) => value;\r\n        }\r\n    }\r\n\r\n    // subscribe attribute & timeseries \r\n    function onDataUpdatedForSubscribe(subscription, apply) {\r\n        if (subscription.data.length) {\r\n            var keyData = subscription.data[0];\r\n            if (keyData && keyData.data && keyData.data[0]) {\r\n                var attrValue = keyData.data[0][1];\r\n                if (attrValue) {\r\n                    try {\r\n                        self.ctx.$scope.currentValue = self.ctx.$scope.originalValue = parseValueFunction(attrValue);  ////angular.fromJson(attrValue)\r\n                    } catch (e){\r\n                        self.ctx.$scope.error = 'parseValueFunction(value) error!';\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        \r\n        if (apply) {\r\n            self.ctx.detectChanges(); //self.ctx.$scope.$digest();\r\n        }\r\n    }\r\n    function onDataUpdateErrorForSubscribe(subscription, e) {\r\n        var exceptionData = utils.parseException(e);\r\n        var errorText = exceptionData.name;\r\n        if (exceptionData.message) {\r\n            errorText += ': ' + exceptionData.message;\r\n        }\r\n        self.ctx.$scope.error = errorText;\r\n    }\r\n    function subscribeAttributesOrTimeseries(type, entityType, entityId, retrieveMethod, key) {\r\n        var valueSubscriptionInfo = [{\r\n            type:       type,\r\n            entityType: entityType,\r\n            entityId:   entityId\r\n        }];\r\n        \r\n        if (retrieveMethod == 'attribute') {\r\n            valueSubscriptionInfo[0].attributes = [\r\n                {name: key}\r\n            ];\r\n        } else {\r\n            valueSubscriptionInfo[0].timeseries = [\r\n                {name: key}\r\n            ];\r\n        }\r\n        \r\n        var subscriptionOptions = {\r\n            callbacks: {\r\n                onDataUpdated: onDataUpdatedForSubscribe,\r\n                onDataUpdateError: onDataUpdateErrorForSubscribe\r\n            }\r\n        };\r\n        self.ctx.subscriptionApi.createSubscriptionFromInfo (\r\n            'latest', valueSubscriptionInfo, subscriptionOptions, false, true).subscribe( //types.widgetType.latest.value\r\n            (subscription) => {\r\n                valueSubscription = subscription;\r\n            }\r\n        );    \r\n    }\r\n    \r\n    // update attribute\r\n    function updateAttributes(entityType, entityId, attributeScope, key, value) { \r\n        let attributes = [];\r\n        attributes.push({\r\n            \"key\": key,                             // attribute name,\r\n            \"value\": convertValueFunction(value)    // attribute value\r\n        });\r\n\r\n        ////attributeService.saveEntityAttributes(self.ctx.datasources[0].entityType, self.ctx.datasources[0].entityId,\r\n        attributeService.saveEntityAttributes({\"entityType\":entityType, \"id\":entityId}, \r\n            attributeScope, attributes).subscribe(\r\n            function success() {\r\n                retrieveValue();  //self.ctx.$scope.originalValue = self.ctx.$scope.currentValue = value;\r\n                self.ctx.$scope.error = \"\";\r\n            },\r\n            function fail(rejection) {\r\n                if (settings.showError) {\r\n                    self.ctx.$scope.error =\r\n                        rejection.status + \": \" +\r\n                        rejection.statusText;\r\n                }\r\n            }\r\n        );\r\n    }\r\n    \r\n    // update timeseries \r\n    function saveEntityTimeseries(entityType, entityId, telemetries) {\r\n        var telemetriesData = {};\r\n        for (var a = 0; a < telemetries.length; a++) {\r\n            if (typeof telemetries[a].value !== 'undefined' && telemetries[a].value !== null) {\r\n                telemetriesData[telemetries[a].key] = telemetries[a].value;\r\n            }\r\n        }\r\n        if (Object.keys(telemetriesData).length) {\r\n            var url = '/api/plugins/telemetry/' + entityType + '/' + entityId + '/timeseries/scope';\r\n            return http.post(url, telemetriesData);\r\n        }\r\n        return null;\r\n    }\r\n    function updateTimeseries(entityType, entityId, key, value) {\r\n        //var datasource = self.ctx.datasources[0];\r\n        let observable = saveEntityTimeseries(\r\n            entityType,     // datasource.entityType,\r\n            entityId,       // datasource.entityId,\r\n            [\r\n                {\r\n                    key: key,\r\n                    value: convertValueFunction(value)\r\n                }\r\n            ]\r\n        );\r\n        if (observable) {\r\n            observable.subscribe(\r\n                function success() {\r\n                    /*if (settings.showResultMessage) {\r\n                        $scope.showSuccessToast(translate.instant('widgets.input-widgets.update-successful'), 1000, 'bottom', 'left', $scope.toastTargetId);\r\n                    }*/\r\n                    retrieveValue();    //$scope.originalValue = $scope.currentValue = value;\r\n                },\r\n                function fail() {\r\n                    /*if (settings.showResultMessage) {\r\n                        $scope.showErrorToast(translate.instant('widgets.input-widgets.update-failed'), 'bottom', 'left', $scope.toastTargetId);\r\n                    }*/\r\n                    self.ctx.$scope.error = translate.instant('widgets.input-widgets.update-failed');\r\n                }\r\n            );\r\n        }\r\n    }\r\n\r\n    // RPC retrieve value\r\n    function rpcRetrieveValue(method, timeout) {\r\n        if (method && method.length) {\r\n            self.ctx.$scope.error = '';\r\n            self.ctx.controlApi.sendTwoWayCommand(method, null, timeout).subscribe(\r\n                function success(responseBody) {\r\n                    ////self.ctx.$scope.currentValue = self.ctx.$scope.originalValue = responseBody;\r\n                    self.ctx.$scope.currentValue = self.ctx.$scope.originalValue = parseValueFunction(responseBody);\r\n\r\n                    ////self.ctx.$scope.$digest(); // Error: $digest already in progress\r\n                },\r\n                function fail() {\r\n                    self.ctx.$scope.error = self.ctx.defaultSubscription.rpcErrorText;\r\n                }\r\n            );\r\n        } else {\r\n            self.ctx.$scope.error = \"retrieveRPCMethod is null.\";\r\n        }\r\n    }\r\n    // RPC update value\r\n    function rpcUpdateValue(method, value, timeout) {\r\n        if (rpcUpdateStatus.executingUpdateValue) {\r\n            rpcUpdateStatus.scheduledValue = value;\r\n            return;\r\n        } else {\r\n            rpcUpdateStatus.scheduledValue = null;\r\n            rpcUpdateStatus.rpcValue = value;\r\n            rpcUpdateStatus.executingUpdateValue = true;\r\n        }\r\n        self.ctx.$scope.error = '';\r\n        self.ctx.controlApi.sendOneWayCommand(method, convertValueFunction(value), timeout).subscribe(\r\n            () => {\r\n                rpcUpdateStatus.executingUpdateValue = false;\r\n                if (rpcUpdateStatus.scheduledValue !== null && rpcUpdateStatus.scheduledValue != rpcUpdateStatus.rpcValue) {\r\n                    rpcUpdateValue(rpcUpdateStatus.scheduledValue);\r\n                } else {\r\n                    retrieveValue(); // self.ctx.$scope.originalValue = self.ctx.$scope.currentValue = value;\r\n                }\r\n            },\r\n            () => {\r\n                rpcUpdateStatus.executingUpdateValue = false;\r\n                self.ctx.$scope.error = self.ctx.defaultSubscription.rpcErrorText;\r\n            }\r\n        );\r\n    }\r\n\r\n    // update value\r\n    self.ctx.$scope.updateValue = function(option) {\r\n        //console.log(\"updateValue()\", settings);\r\n        \r\n        if (settings.updateMethod === \"SHARED_SCOPE\" || settings.updateMethod === \"SERVER_SCOPE\") {\r\n            updateAttributes(\"DEVICE\", //types.entityType.device, \r\n                self.ctx.defaultSubscription.targetDeviceId, \r\n                settings.updateMethod, \r\n                settings.updateAttributeKey, \r\n                option.attributeValue);\r\n                \r\n        } else if (settings.updateMethod === \"timeseries\") {\r\n            updateTimeseries(\"DEVICE\", // types.entityType.device,  types.constant.js\r\n                self.ctx.defaultSubscription.targetDeviceId, \r\n                settings.updateAttributeKey, \r\n                option.attributeValue);\r\n                \r\n        } else if (settings.updateMethod === \"rpc\") {\r\n            rpcUpdateValue(settings.updateRPCMethod, \r\n                option.attributeValue, \r\n                settings.requestTimeout);\r\n            \r\n        } else {\r\n            self.ctx.$scope.error = \"updateMethod is error!\";\r\n\r\n        }\r\n    }\r\n\r\n    // retrieve value\r\n    var firstRetrieveValue = true;\r\n    function retrieveValue() {\r\n        let rpcEnabled = self.ctx.defaultSubscription.rpcEnabled;\r\n        let isSimulated = self.ctx.$scope.widgetEditMode;\r\n        if (!rpcEnabled) {\r\n            self.ctx.$scope.error = 'Target device is not set!';\r\n        } else {\r\n            if (!isSimulated) {\r\n                if (settings.retrieveMethod == 'rpc') {\r\n                    rpcRetrieveValue(settings.retrieveRPCMethod, settings.requestTimeout);\r\n                } else if (settings.retrieveMethod == 'attribute' || settings.retrieveMethod == 'timeseries') {\r\n                    if (firstRetrieveValue) {\r\n                        subscribeAttributesOrTimeseries(\"entity\", // types.datasourceType.entity, in types.constant.js\r\n                            \"DEVICE\", //types.entityType.device, in types.constant.js\r\n                            self.ctx.defaultSubscription.targetDeviceId, \r\n                            settings.retrieveMethod, \r\n                            settings.retrieveAttributeKey);\r\n                    }\r\n                }\r\n            } \r\n        }\r\n        \r\n        firstRetrieveValue = false;\r\n    }\r\n    \r\n    retrieveValue();\r\n};\r\n\r\nself.onResize = function() {\r\n};\r\n\r\nself.onDestory = function() {\r\n    if (valueSubscription) {\r\n        self.ctx.subscriptionApi.removeSubscription(valueSubscription.id);\r\n    }\r\n};\r\n\r\n/*self.onDataUpdated = function() {\r\n    try{\r\n        self.ctx.$scope.currentValue = self.ctx.$scope.originalValue = self.ctx.data[0].data[0][1];\r\n        self.ctx.$scope.$digest();\r\n    } catch (e) {\r\n        console.log(e);\r\n    }\r\n}*/\r\n\r\n/*self.typeParameters = function() {\r\n    return {\r\n        maxDatasources: 1, // Maximum allowed datasources for this widget, -1 - unlimited\r\n        maxDataKeys: 1 //Maximum allowed data keys for this widget, -1 - unlimited\r\n    }\r\n};*/\r\n",
        "settingsSchema": "{\r\n    \"schema\": {\r\n        \"type\": \"object\",\r\n        \"title\": \"Settings\",\r\n        \"properties\": {\r\n            \"title\": {\r\n                \"title\": \"Widget title\",\r\n                \"type\": \"string\",\r\n                \"default\": \"\"\r\n            },\r\n            \r\n            \"retrieveMethod\": {\r\n                \"title\": \"Retrieve string value using method\",\r\n                \"type\": \"string\",\r\n                \"default\": \"rpc\"\r\n            },\r\n            \"retrieveAttributeKey\": {\r\n                \"title\": \"Retrieve Attribute/Timeseries value key (only when subscribe for attribute/timeseries method)\",\r\n                \"type\": \"string\",\r\n                \"default\": \"\"\r\n            },\r\n            \"retrieveRPCMethod\": {\r\n                \"title\": \"Retrieve value using RPC method (only when call RPC get value method)\",\r\n                \"type\": \"string\",\r\n                \"default\": \"\"\r\n            },\r\n            \"parseValueFunction\": {\r\n                \"title\": \"Parse value function, f(data), returns string\",\r\n                \"type\": \"string\",\r\n                \"default\": \"return data; /* console.log(data); */ \"\r\n            },\r\n            \r\n            \"updateMethod\": {\r\n                \"title\": \"Update string value using method\",\r\n                \"type\": \"string\",\r\n                \"default\": \"rpc\"\r\n            },\r\n            \"updateAttributeKey\": {\r\n                \"title\": \"Update Attribute/Timeseries value key (only when update for attribute/timeseries method)\",\r\n                \"type\": \"string\",\r\n                \"default\": \"\"\r\n            },\r\n            \"updateRPCMethod\": {\r\n                \"title\": \"Update value using RPC method (only when call RPC set value method)\",\r\n                \"type\": \"string\",\r\n                \"default\": \"\"\r\n            },\r\n            \"convertValueFunction\": {\r\n                \"title\": \"Convert value function, f(value), returns payload used by RPC set value method\",\r\n                \"type\": \"string\",\r\n                \"default\": \"return value; /* console.log(value); */\"\r\n            },\r\n\r\n            \"requestTimeout\": {\r\n                \"title\": \"RPC request timeout\",\r\n                \"type\": \"number\",\r\n                \"default\": 5000\r\n            },\r\n\r\n            \"options\":{\r\n                \"type\": \"array\",\r\n                \"title\": \"Options\",\r\n                \"minItems\": 1,\r\n                \"maxItems\": 30,\r\n                \"items\": {\r\n                    \"type\": \"object\",\r\n                    \"properties\": {\r\n                        \"optionLabel\": {\r\n                            \"title\": \"Option label\",\r\n                            \"type\": \"string\",\r\n                            \"default\": \"Option label\"\r\n                        },\r\n                        \"attributeValue\": {\r\n                            \"title\": \"Attribute value\",\r\n                            \"type\": \"string\",\r\n                            \"description\": \"Attribute value.\"\r\n                        }\r\n                    }, \r\n                    \"required\": [\r\n                        \"optionLabel\",\r\n                        \"attributeValue\"\r\n                    ]\r\n                }\r\n            },\r\n            \"optionStyle\":{\r\n                \"type\": \"object\",\r\n                \"title\": \"Option Style\",\r\n                \"properties\": {\r\n                    \"orientation\": {\r\n                        \"type\": \"string\",\r\n                        \"title\": \"Orientation\",\r\n                        \"default\": \"column\"\r\n                    },\r\n                    \"isRaised\": {\r\n                        \"type\": \"boolean\",\r\n                        \"title\": \"Raised\",\r\n                        \"default\": true\r\n                    },\r\n                    \"checkedOption\": {\r\n                        \"type\": \"object\",\r\n                        \"title\": \"Checked Option Style\",\r\n                        \"properties\": {\r\n                            \"isPrimary\": {\r\n                                \"type\": \"boolean\",\r\n                                \"title\": \"Primary color\",\r\n                                \"default\": true\r\n                            },\r\n                            \"bgColor\": {\r\n                                \"type\": \"string\",\r\n                                \"title\": \"Checked option background color\",\r\n                                \"default\": null\r\n                            },\r\n                            \"textColor\": {\r\n                                \"type\": \"string\",\r\n                                \"title\": \"Checked option text color\",\r\n                                \"default\": null\r\n                            }\r\n                        }\r\n                    },\r\n                    \"uncheckedOption\": {\r\n                        \"type\": \"object\",\r\n                        \"title\": \"Unchecked Option Style\",\r\n                        \"properties\": {\r\n                            \"isPrimary\": {\r\n                                \"type\": \"boolean\",\r\n                                \"title\": \"Primary color\",\r\n                                \"default\": true\r\n                            },\r\n                            \"bgColor\": {\r\n                                \"type\": \"string\",\r\n                                \"title\": \"Unchecked option background color\",\r\n                                \"default\": null\r\n                            },\r\n                            \"textColor\": {\r\n                                \"type\": \"string\",\r\n                                \"title\": \"Unchecked option text color\",\r\n                                \"default\": null\r\n                            }\r\n                        }\r\n                    }\r\n                },\r\n                \"required\": [\r\n                    \"orientation\",\r\n                    \"isRaised\",\r\n                    \"checkedOption\",\r\n                    \"uncheckedOption\"\r\n                ]\r\n            },\r\n            \r\n            \"required\": [\r\n                \"retrieveMethod\",\r\n                \"updateMethod\", \r\n                \"options\",\r\n                \"optionStyle\"\r\n            ]\r\n        }\r\n    },\r\n    \"form\": [\r\n        \"title\",\r\n\r\n        {\r\n            \"key\": \"retrieveMethod\",\r\n            \"type\": \"rc-select\",\r\n            \"multiple\": false,\r\n            \"items\": [\r\n                {\r\n                    \"value\": \"none\",\r\n                    \"label\": \"Don't retrieve\"\r\n                },\r\n                {\r\n                    \"value\": \"attribute\",\r\n                    \"label\": \"Subscribe for attribute\"\r\n                },\r\n                {\r\n                    \"value\": \"timeseries\",\r\n                    \"label\": \"Subscribe for timeseries\"\r\n                },\r\n                {\r\n                    \"value\": \"rpc\",\r\n                    \"label\": \"Call RPC get value method\"\r\n                }\r\n            ]\r\n        },\r\n        \"retrieveAttributeKey\",\r\n        \"retrieveRPCMethod\",\r\n        {\r\n            \"key\": \"parseValueFunction\",\r\n            \"type\": \"javascript\"\r\n        },\r\n        \r\n        {\r\n            \"key\": \"updateMethod\",\r\n            \"type\": \"rc-select\",\r\n            \"multiple\": false,\r\n            \"items\": [\r\n                {\r\n                    \"value\": \"SHARED_SCOPE\",\r\n                    \"label\": \"Update shared attribute\"\r\n                },\r\n                {\r\n                    \"value\": \"SERVER_SCOPE\",\r\n                    \"label\": \"Update server attribute\"\r\n                },\r\n                {\r\n                    \"value\": \"timeseries\",\r\n                    \"label\": \"Update timeseries\"\r\n                },\r\n                {\r\n                    \"value\": \"rpc\",\r\n                    \"label\": \"Call RPC set value method\"\r\n                }\r\n            ]\r\n        },\r\n        \"updateAttributeKey\",\r\n        \"updateRPCMethod\",\r\n        {\r\n            \"key\": \"convertValueFunction\",\r\n            \"type\": \"javascript\"\r\n        },\r\n        \r\n        \"requestTimeout\",\r\n        \r\n        {\r\n            \"key\": \"options\",\r\n            \"items\": [\r\n                \"options[]\"\r\n            ]\r\n        }, \r\n        {\r\n            \"key\": \"optionStyle\",\r\n            \"items\" :[\r\n                {\r\n                    \"key\": \"optionStyle.orientation\",\r\n                    \"type\": \"rc-select\",\r\n                    \"multiple\": false,\r\n                    \"items\": [{\r\n                        \"value\": \"column\",\r\n                        \"label\": \"Column\"\r\n                    }, {\r\n                        \"value\": \"row\",\r\n                        \"label\": \"Row\"\r\n                    }]\r\n                },\r\n                \"optionStyle.isRaised\",\r\n                {\r\n                    \"key\": \"optionStyle.checkedOption\",\r\n                    \"items\": [\r\n                        \"optionStyle.checkedOption.isPrimary\",\r\n                        {\r\n                            \"key\": \"optionStyle.checkedOption.bgColor\",\r\n                            \"type\": \"color\"\r\n                        },\r\n                        {\r\n                            \"key\": \"optionStyle.checkedOption.textColor\",\r\n                            \"type\": \"color\"\r\n                        }\r\n                    ]\r\n                }, {\r\n                    \"key\": \"optionStyle.uncheckedOption\",\r\n                    \"items\": [\r\n                        \"optionStyle.uncheckedOption.isPrimary\",\r\n                        {\r\n                            \"key\": \"optionStyle.uncheckedOption.bgColor\",\r\n                            \"type\": \"color\"\r\n                        },\r\n                        {\r\n                            \"key\": \"optionStyle.uncheckedOption.textColor\",\r\n                            \"type\": \"color\"\r\n                        }\r\n                    ]\r\n                }\r\n            ]\r\n        }\r\n    ]\r\n}\r\n",
        "dataKeySettingsSchema": "{}\r\n",
        "defaultConfig": "{\"showTitle\":true,\"backgroundColor\":\"#e6e7e8\",\"color\":\"rgba(0, 0, 0, 0.87)\",\"padding\":\"8px\",\"settings\":{\"optionStyle\":{\"orientation\":\"column\",\"isRaised\":true,\"checkedOption\":{\"isPrimary\":true},\"uncheckedOption\":{\"isPrimary\":false}},\"options\":[{\"optionLabel\":\"Option1 Label\",\"attributeValue\":\"option1\"},{\"optionLabel\":\"Option2 Label\",\"attributeValue\":\"option2\"}],\"retrieveMethod\":\"rpc\",\"retrieveAttributeKey\":\"value\",\"retrieveRPCMethod\":\"getValue\",\"parseValueFunction\":\"/* console.log(data); */\\nreturn data;\",\"updateMethod\":\"rpc\",\"updateAttributeKey\":\"value\",\"updateRPCMethod\":\"setValue\",\"convertValueFunction\":\"/* console.log(value); */\\nreturn value;\",\"requestTimeout\":5000},\"title\":\"Segmented switch of string value\",\"showTitleIcon\":false,\"titleIcon\":\"more_horiz\",\"iconColor\":\"rgba(0, 0, 0, 0.87)\",\"iconSize\":\"24px\",\"titleTooltip\":\"\",\"dropShadow\":true,\"enableFullscreen\":false,\"widgetStyle\":{},\"titleStyle\":{\"fontSize\":\"16px\",\"fontWeight\":400},\"useDashboardTimewindow\":true,\"displayTimewindow\":true,\"showLegend\":false,\"actions\":{},\"targetDeviceAliases\":[]}"
      }
    },
    {
      "alias": "segment_switch_of_boolean",
      "name": "Segment switch of boolean value",
      "descriptor": {
        "type": "rpc",
        "sizeX": 7.5,
        "sizeY": 3,
        "resources": [],
        "templateHtml": "<div class=\"tb-rpc-button\" fxLayout=\"column\">\r\n    <div fxFlex=\"{{showTitle ? 20 : 0}}\" class=\"title-container\" fxLayout=\"row\"\r\n        fxLayoutAlign=\"center center\" [fxShow]=\"showTitle\">\r\n        <span class=\"button-title\">{{title}}</span>\r\n    </div>\r\n    <div fxFlex=\"{{showTitle ? 80 : 100}}\" [ngStyle]=\"{paddingTop: showTitle ? '5px': '5px'}\"\r\n        class=\"button-container\" fxLayout=\"{{optionStyle?.orientation}}\" fxLayoutAlign=\"center center\"> \r\n            <button mat-button (click)=\"updateValue(true)\" \r\n                [class.mat-raised-button]=\"optionStyle?.isRaised\" \r\n\t\t\t\t[color]=\"(true===currentValue ? optionStyle?.checkedOption.isPrimary : optionStyle?.uncheckedOption.isPrimary) ? 'primary' : ''\" \r\n\t\t\t\t[ngStyle]=\"true===currentValue ? customCheckedStyle : customUncheckedStyle\">\r\n                {{options?.trueLabel}}\r\n            </button>\r\n            \r\n            <button mat-button (click)=\"updateValue(false)\" \r\n                [class.mat-raised-button]=\"optionStyle?.isRaised\" \r\n\t\t\t\t[color]=\"(false===currentValue ? optionStyle?.checkedOption.isPrimary : optionStyle?.uncheckedOption.isPrimary) ? 'primary' : ''\" \r\n\t\t\t\t[ngStyle]=\"false===currentValue ? customCheckedStyle : customUncheckedStyle\">\r\n                {{options?.falseLabel}}\r\n            </button>\r\n            \r\n    </div>\r\n    <div class=\"error-container\" [ngStyle]=\"{'background': error?.length ? 'rgba(255,255,255,0.25)' : 'none'}\"\r\n         fxLayout=\"row\" fxLayoutAlign=\"center center\">\r\n        <span class=\"button-error\">{{ error }}</span>\r\n    </div>\r\n</div>\r\n",
        "templateCss": ".tb-rpc-button {\r\n    width: 100%;\r\n    height: 100%;\r\n}\r\n\r\n.tb-rpc-button .title-container {\r\n    font-weight: 500;\r\n    white-space: nowrap;\r\n    margin: 10px 0;\r\n}\r\n\r\n.tb-rpc-button .button-container div{\r\n    min-width: 80%\r\n}\r\n\r\n.tb-rpc-button .button-container .mat-button{\r\n    width: 100%;\r\n    margin: 0;\r\n}\r\n\r\n.tb-rpc-button .button-container .mat-button{\r\n    padding: 0 4px;\r\n}\r\n\r\n.tb-rpc-button .error-container {\r\n    position: absolute;\r\n    top: 2%;\r\n    right: 0;\r\n    left: 0;\r\n    z-index: 4;\r\n    height: 14px;\r\n}\r\n\r\n.tb-rpc-button .error-container .button-error {\r\n    color: #ff3315;\r\n    white-space: nowrap;\r\n}",
        "controllerScript": "let valueSubscription;\r\n\r\nself.onInit = function() {\r\n    self.ctx.ngZone.run(function() {\r\n       init();\r\n       self.ctx.detectChanges(true);\r\n    });\r\n};\r\n\r\nfunction init() {\r\n    let utils       = self.ctx.$scope.$injector.get(self.ctx.servicesMap.get('utils'));\r\n    //let types       = self.ctx.$scope.$injector.get(self.ctx.servicesMap.get('types'));\r\n    //let toast       = self.ctx.$scope.$injector.get(self.ctx.servicesMap.get('toast'));\r\n    let translate   = self.ctx.$scope.$injector.get(self.ctx.servicesMap.get('translate'));\r\n    //let $q          = self.ctx.$scope.$injector.get(self.ctx.servicesMap.get('$q'));\r\n    let http        = self.ctx.$scope.$injector.get(self.ctx.servicesMap.get('http'));\r\n    let attributeService = self.ctx.$scope.$injector.get(self.ctx.servicesMap.get('attributeService'));\r\n    let rpcUpdateStatus = {};\r\n    let settings = utils.deepClone(self.ctx.settings) || {}; \r\n    \r\n    self.ctx.$scope.toastTargetId = 'input-widget' + utils.guid();\r\n    self.ctx.$scope.showTitle = settings.title && settings.title.length ? true : false; ////utils.defaultValue(settings.title, true);\r\n    self.ctx.$scope.title = settings.title;\r\n    self.ctx.$scope.options = settings.options;\r\n    self.ctx.$scope.optionStyle = settings.optionStyle;\r\n\r\n    self.ctx.$scope.customCheckedStyle = {};\r\n    self.ctx.$scope.customCheckedStyle['min-width'] = '40px';\r\n    self.ctx.$scope.customCheckedStyle['padding']   = '0 2px';\r\n    if (self.ctx.settings.optionStyle.orientation === 'column') {\r\n        self.ctx.$scope.customCheckedStyle['width']     = '100%';\r\n        self.ctx.$scope.customCheckedStyle['margin']    = 0;\r\n    } else {\r\n        self.ctx.$scope.customCheckedStyle['width']     = 100/2 + '%';\r\n        self.ctx.$scope.customCheckedStyle['margin']    = 0;\r\n    }\r\n    if (self.ctx.settings.optionStyle.checkedOption.isPrimary === false) {\r\n        self.ctx.$scope.customCheckedStyle['background-color']  = self.ctx.$scope.optionStyle.checkedOption.bgColor;\r\n        self.ctx.$scope.customCheckedStyle['color']             = self.ctx.$scope.optionStyle.checkedOption.textColor;\r\n    }\r\n\r\n    self.ctx.$scope.customUncheckedStyle = {};\r\n    self.ctx.$scope.customUncheckedStyle['min-width'] = '40px';\r\n    self.ctx.$scope.customUncheckedStyle['padding']   = '0 2px';\r\n    if (self.ctx.settings.optionStyle.orientation === \"column\") {\r\n        self.ctx.$scope.customUncheckedStyle['width']     = '100%';\r\n        self.ctx.$scope.customUncheckedStyle['margin']    = 0;\r\n    } else {\r\n        self.ctx.$scope.customUncheckedStyle['width']     = 100/2 + '%';\r\n        self.ctx.$scope.customUncheckedStyle['margin']    = 0;\r\n    }\r\n    if (self.ctx.settings.optionStyle.uncheckedOption.isPrimary === false) {\r\n        self.ctx.$scope.customUncheckedStyle['background-color']  = self.ctx.$scope.optionStyle.uncheckedOption.bgColor;\r\n        self.ctx.$scope.customUncheckedStyle['color']             = self.ctx.$scope.optionStyle.uncheckedOption.textColor;\r\n    }\r\n    \r\n    \r\n    //console.log(\"onInit\", settings);\r\n    \r\n    function translateToBoolean(updateValue) {\r\n        if (updateValue) {\r\n            if (typeof updateValue === \"string\") {\r\n                if (updateValue===\"true\" || updateValue===\"True\" || updateValue===\"TRUE\") {\r\n                    return true;\r\n                } else if (updateValue===\"false\" || updateValue===\"False\" || updateValue===\"FALSE\") {\r\n                    return false;\r\n                } \r\n            }/* else if (typeof updateValue === \"number\") {\r\n                return (updateValue===0) ? false : true;\r\n            }*/\r\n        }\r\n        \r\n        return updateValue;\r\n    }\r\n\r\n    let parseValueFunction = (data) => data;        // Retrieve data\r\n    if (settings.parseValueFunction && settings.parseValueFunction.length) {\r\n        try {\r\n            parseValueFunction = new Function('data', settings.parseValueFunction);\r\n        } catch (e) {\r\n            parseValueFunction = (data) => data;    //? true : false;\r\n        }\r\n    }\r\n    \r\n    let convertValueFunction = (value) => value;    // Update data\r\n    if (settings.convertValueFunction && settings.convertValueFunction.length) {\r\n        try {\r\n            convertValueFunction = new Function('value', settings.convertValueFunction);\r\n        } catch (e) {\r\n            convertValueFunction = (value) => value; //? true : false;\r\n        }\r\n    }\r\n\r\n    // subscribe attribute & timeseries \r\n    function onDataUpdatedForSubscribe(subscription, apply) {\r\n        if (subscription.data.length) {\r\n            var keyData = subscription.data[0];\r\n            if (keyData && keyData.data && keyData.data[0]) {\r\n                var attrValue = keyData.data[0][1];\r\n                if (attrValue) {\r\n                    try {\r\n                        self.ctx.$scope.currentValue = self.ctx.$scope.originalValue = parseValueFunction(translateToBoolean(attrValue));  ////angular.fromJson(attrValue)\r\n                    } catch (e){\r\n                        self.ctx.$scope.error = 'parseValueFunction(value) error!';\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        \r\n        if (apply) {\r\n            self.ctx.detectChanges(); //self.ctx.$scope.$digest();\r\n        }\r\n    }\r\n    function onDataUpdateErrorForSubscribe(subscription, e) {\r\n        var exceptionData = utils.parseException(e);\r\n        var errorText = exceptionData.name;\r\n        if (exceptionData.message) {\r\n            errorText += ': ' + exceptionData.message;\r\n        }\r\n        self.ctx.$scope.error = errorText;\r\n    }\r\n    function subscribeAttributesOrTimeseries(type, entityType, entityId, retrieveMethod, key) {\r\n        var valueSubscriptionInfo = [{\r\n            type:       type,\r\n            entityType: entityType,\r\n            entityId:   entityId\r\n        }];\r\n        \r\n        if (retrieveMethod == 'attribute') {\r\n            valueSubscriptionInfo[0].attributes = [\r\n                {name: key}\r\n            ];\r\n        } else {\r\n            valueSubscriptionInfo[0].timeseries = [\r\n                {name: key}\r\n            ];\r\n        }\r\n        \r\n        var subscriptionOptions = {\r\n            callbacks: {\r\n                onDataUpdated: onDataUpdatedForSubscribe,\r\n                onDataUpdateError: onDataUpdateErrorForSubscribe\r\n            }\r\n        };\r\n        self.ctx.subscriptionApi.createSubscriptionFromInfo (\r\n            'latest', valueSubscriptionInfo, subscriptionOptions, false, true).subscribe( //types.widgetType.latest.value\r\n            (subscription) => {\r\n                valueSubscription = subscription;\r\n            }\r\n        );    \r\n    }\r\n    \r\n    // update attribute\r\n    function updateAttributes(entityType, entityId, attributeScope, key, value) { \r\n        let attributes = [];\r\n        attributes.push({\r\n            \"key\": key,                             // attribute name,\r\n            \"value\": convertValueFunction(value)    // attribute value\r\n        });\r\n\r\n        ////attributeService.saveEntityAttributes(self.ctx.datasources[0].entityType, self.ctx.datasources[0].entityId,\r\n        attributeService.saveEntityAttributes({\"entityType\":entityType, \"id\":entityId}, \r\n            attributeScope, attributes).subscribe(\r\n            function success() {\r\n                retrieveValue();  //self.ctx.$scope.originalValue = self.ctx.$scope.currentValue = value;\r\n                self.ctx.$scope.error = \"\";\r\n            },\r\n            function fail(rejection) {\r\n                if (settings.showError) {\r\n                    self.ctx.$scope.error =\r\n                        rejection.status + \": \" +\r\n                        rejection.statusText;\r\n                }\r\n            }\r\n        );\r\n    }\r\n    \r\n    // update timeseries \r\n    function saveEntityTimeseries(entityType, entityId, telemetries) {\r\n        var telemetriesData = {};\r\n        for (var a = 0; a < telemetries.length; a++) {\r\n            if (typeof telemetries[a].value !== 'undefined' && telemetries[a].value !== null) {\r\n                telemetriesData[telemetries[a].key] = telemetries[a].value;\r\n            }\r\n        }\r\n        if (Object.keys(telemetriesData).length) {\r\n            var url = '/api/plugins/telemetry/' + entityType + '/' + entityId + '/timeseries/scope';\r\n            return http.post(url, telemetriesData);\r\n        }\r\n        return null;\r\n    }\r\n    function updateTimeseries(entityType, entityId, key, value) {\r\n        //var datasource = self.ctx.datasources[0];\r\n        let observable = saveEntityTimeseries(\r\n            entityType,     // datasource.entityType,\r\n            entityId,       // datasource.entityId,\r\n            [\r\n                {\r\n                    key: key,\r\n                    value: convertValueFunction(value)\r\n                }\r\n            ]\r\n        );\r\n        if (observable) {\r\n            observable.subscribe(\r\n                function success() {\r\n                    /*if (settings.showResultMessage) {\r\n                        $scope.showSuccessToast(translate.instant('widgets.input-widgets.update-successful'), 1000, 'bottom', 'left', $scope.toastTargetId);\r\n                    }*/\r\n                    retrieveValue();    //$scope.originalValue = $scope.currentValue = value;\r\n                },\r\n                function fail() {\r\n                    /*if (settings.showResultMessage) {\r\n                        $scope.showErrorToast(translate.instant('widgets.input-widgets.update-failed'), 'bottom', 'left', $scope.toastTargetId);\r\n                    }*/\r\n                    self.ctx.$scope.error = translate.instant('widgets.input-widgets.update-failed');\r\n                }\r\n            );\r\n        }\r\n    }\r\n\r\n    // RPC retrieve value\r\n    function rpcRetrieveValue(method, timeout) {\r\n        if (method && method.length) {\r\n            self.ctx.$scope.error = '';\r\n            self.ctx.controlApi.sendTwoWayCommand(method, null, timeout).subscribe(\r\n                function success(responseBody) {\r\n                    ////self.ctx.$scope.currentValue = self.ctx.$scope.originalValue = responseBody;\r\n                    self.ctx.$scope.currentValue = self.ctx.$scope.originalValue = parseValueFunction(translateToBoolean(responseBody));\r\n\r\n                    ////self.ctx.$scope.$digest(); // Error: $digest already in progress\r\n                },\r\n                function fail() {\r\n                    self.ctx.$scope.error = self.ctx.defaultSubscription.rpcErrorText;\r\n                }\r\n            );\r\n        } else {\r\n            self.ctx.$scope.error = \"retrieveRPCMethod is null.\";\r\n        }\r\n    }\r\n    // RPC update value\r\n    function rpcUpdateValue(method, value, timeout) {\r\n        if (rpcUpdateStatus.executingUpdateValue) {\r\n            rpcUpdateStatus.scheduledValue = value;\r\n            return;\r\n        } else {\r\n            rpcUpdateStatus.scheduledValue = null;\r\n            rpcUpdateStatus.rpcValue = value;\r\n            rpcUpdateStatus.executingUpdateValue = true;\r\n        }\r\n        self.ctx.$scope.error = '';\r\n        self.ctx.controlApi.sendOneWayCommand(method, convertValueFunction(value), timeout).subscribe(\r\n            () => {\r\n                rpcUpdateStatus.executingUpdateValue = false;\r\n                if (rpcUpdateStatus.scheduledValue !== null && rpcUpdateStatus.scheduledValue != rpcUpdateStatus.rpcValue) {\r\n                    rpcUpdateValue(rpcUpdateStatus.scheduledValue);\r\n                } else {\r\n                    retrieveValue(); // self.ctx.$scope.originalValue = self.ctx.$scope.currentValue = value;\r\n                }\r\n            },\r\n            () => {\r\n                rpcUpdateStatus.executingUpdateValue = false;\r\n                self.ctx.$scope.error = self.ctx.defaultSubscription.rpcErrorText;\r\n            }\r\n        );\r\n    }\r\n\r\n    // update value\r\n    self.ctx.$scope.updateValue = function(optionValue) {\r\n        //console.log(\"updateValue()\", settings);\r\n        \r\n        if (settings.updateMethod === \"SHARED_SCOPE\" || settings.updateMethod === \"SERVER_SCOPE\") {\r\n            updateAttributes(\"DEVICE\", //types.entityType.device, \r\n                self.ctx.defaultSubscription.targetDeviceId, \r\n                settings.updateMethod, \r\n                settings.updateAttributeKey, \r\n                optionValue);\r\n                \r\n        } else if (settings.updateMethod === \"timeseries\") {\r\n            updateTimeseries(\"DEVICE\", // types.entityType.device,  types.constant.js\r\n                self.ctx.defaultSubscription.targetDeviceId, \r\n                settings.updateAttributeKey, \r\n                optionValue);\r\n                \r\n        } else if (settings.updateMethod === \"rpc\") {\r\n            rpcUpdateValue(settings.updateRPCMethod, \r\n                optionValue, \r\n                settings.requestTimeout);\r\n            \r\n        } else {\r\n            self.ctx.$scope.error = \"updateMethod is error!\";\r\n\r\n        }\r\n    }\r\n\r\n    // retrieve value\r\n    var firstRetrieveValue = true;\r\n    function retrieveValue() {\r\n        let rpcEnabled = self.ctx.defaultSubscription.rpcEnabled;\r\n        let isSimulated = self.ctx.$scope.widgetEditMode;\r\n        if (!rpcEnabled) {\r\n            self.ctx.$scope.error = 'Target device is not set!';\r\n        } else {\r\n            if (!isSimulated) {\r\n                if (settings.retrieveMethod == 'rpc') {\r\n                    rpcRetrieveValue(settings.retrieveRPCMethod, settings.requestTimeout);\r\n                } else if (settings.retrieveMethod == 'attribute' || settings.retrieveMethod == 'timeseries') {\r\n                    if (firstRetrieveValue) {\r\n                        subscribeAttributesOrTimeseries(\"entity\", // types.datasourceType.entity, in types.constant.js\r\n                            \"DEVICE\", //types.entityType.device, in types.constant.js\r\n                            self.ctx.defaultSubscription.targetDeviceId, \r\n                            settings.retrieveMethod, \r\n                            settings.retrieveAttributeKey);\r\n                    }\r\n                }\r\n            } \r\n        }\r\n        \r\n        firstRetrieveValue = false;\r\n    }\r\n    \r\n    retrieveValue();\r\n};\r\n\r\nself.onResize = function() {\r\n};\r\n\r\nself.onDestory = function() {\r\n    if (valueSubscription) {\r\n        self.ctx.subscriptionApi.removeSubscription(valueSubscription.id);\r\n    }\r\n};\r\n\r\n/*self.onDataUpdated = function() {\r\n    try{\r\n        self.ctx.$scope.currentValue = self.ctx.$scope.originalValue = self.ctx.data[0].data[0][1];\r\n        self.ctx.$scope.$digest();\r\n    } catch (e) {\r\n        console.log(e);\r\n    }\r\n}*/\r\n\r\n/*self.typeParameters = function() {\r\n    return {\r\n        maxDatasources: 1, // Maximum allowed datasources for this widget, -1 - unlimited\r\n        maxDataKeys: 1 //Maximum allowed data keys for this widget, -1 - unlimited\r\n    }\r\n};*/\r\n",
        "settingsSchema": "{\r\n    \"schema\": {\r\n        \"type\": \"object\",\r\n        \"title\": \"Settings\",\r\n        \"properties\": {\r\n            \"title\": {\r\n                \"title\": \"Widget title\",\r\n                \"type\": \"string\",\r\n                \"default\": \"\"\r\n            },\r\n            \r\n            \"retrieveMethod\": {\r\n                \"title\": \"Retrieve boolean value using method\",\r\n                \"type\": \"string\",\r\n                \"default\": \"rpc\"\r\n            },\r\n            \"retrieveAttributeKey\": {\r\n                \"title\": \"Retrieve Attribute/Timeseries value key (only when subscribe for attribute/timeseries method)\",\r\n                \"type\": \"string\",\r\n                \"default\": \"\"\r\n            },\r\n            \"retrieveRPCMethod\": {\r\n                \"title\": \"Retrieve value using RPC method (only when call RPC get value method)\",\r\n                \"type\": \"string\",\r\n                \"default\": \"\"\r\n            },\r\n            \"parseValueFunction\": {\r\n                \"title\": \"Parse value function, f(data), returns boolean\",\r\n                \"type\": \"string\",\r\n                \"default\": \"return data; /* console.log(data); return data ? true : false; */ \"\r\n            },\r\n            \r\n            \"updateMethod\": {\r\n                \"title\": \"Update string value using method\",\r\n                \"type\": \"string\",\r\n                \"default\": \"rpc\"\r\n            },\r\n            \"updateAttributeKey\": {\r\n                \"title\": \"Update Attribute/Timeseries value key (only when update for attribute/timeseries method)\",\r\n                \"type\": \"string\",\r\n                \"default\": \"\"\r\n            },\r\n            \"updateRPCMethod\": {\r\n                \"title\": \"Update value using RPC method (only when call RPC set value method)\",\r\n                \"type\": \"string\",\r\n                \"default\": \"\"\r\n            },\r\n            \"convertValueFunction\": {\r\n                \"title\": \"Convert value function, f(value), returns payload used by RPC set value method\",\r\n                \"type\": \"string\",\r\n                \"default\": \"return value; /* console.log(value); return value ? true : false;*/ \"\r\n            },\r\n\r\n            \"requestTimeout\": {\r\n                \"title\": \"RPC request timeout\",\r\n                \"type\": \"number\",\r\n                \"default\": 5000\r\n            },\r\n\r\n            \"options\": {\r\n                \"type\": \"object\",\r\n                \"title\": \"Options\",\r\n                \"properties\": {\r\n                    \"trueLabel\": {\r\n                        \"title\": \"True label\",\r\n                        \"type\": \"string\",\r\n                        \"default\": \"True label\"\r\n                    },\r\n                    \"falseLabel\": {\r\n                        \"title\": \"False label\",\r\n                        \"type\": \"string\",\r\n                        \"default\": \"False label\"\r\n                    }, \r\n                    \"required\": [\r\n                        \"falseLabel\",\r\n                        \"trueLabel\"\r\n                    ]\r\n                }\r\n            },\r\n            \"optionStyle\":{\r\n                \"type\": \"object\",\r\n                \"title\": \"Option Style\",\r\n                \"properties\": {\r\n                    \"orientation\": {\r\n                        \"type\": \"string\",\r\n                        \"title\": \"Orientation\",\r\n                        \"default\": \"column\"\r\n                    },\r\n                    \"isRaised\": {\r\n                        \"type\": \"boolean\",\r\n                        \"title\": \"Raised\",\r\n                        \"default\": true\r\n                    },\r\n                    \"checkedOption\": {\r\n                        \"type\": \"object\",\r\n                        \"title\": \"Checked Option Style\",\r\n                        \"properties\": {\r\n                            \"isPrimary\": {\r\n                                \"type\": \"boolean\",\r\n                                \"title\": \"Primary color\",\r\n                                \"default\": true\r\n                            },\r\n                            \"bgColor\": {\r\n                                \"type\": \"string\",\r\n                                \"title\": \"Checked option background color\",\r\n                                \"default\": null\r\n                            },\r\n                            \"textColor\": {\r\n                                \"type\": \"string\",\r\n                                \"title\": \"Checked option text color\",\r\n                                \"default\": null\r\n                            }\r\n                        }\r\n                    },\r\n                    \"uncheckedOption\": {\r\n                        \"type\": \"object\",\r\n                        \"title\": \"Unchecked Option Style\",\r\n                        \"properties\": {\r\n                            \"isPrimary\": {\r\n                                \"type\": \"boolean\",\r\n                                \"title\": \"Primary color\",\r\n                                \"default\": false\r\n                            },\r\n                            \"bgColor\": {\r\n                                \"type\": \"string\",\r\n                                \"title\": \"Unchecked option background color\",\r\n                                \"default\": null\r\n                            },\r\n                            \"textColor\": {\r\n                                \"type\": \"string\",\r\n                                \"title\": \"Unchecked option text color\",\r\n                                \"default\": null\r\n                            }\r\n                        }\r\n                    }\r\n                },\r\n                \"required\": [\r\n                    \"orientation\",\r\n                    \"isRaised\",\r\n                    \"checkedOption\",\r\n                    \"uncheckedOption\"\r\n                ]\r\n            },\r\n            \r\n            \"required\": [\r\n                \"retrieveMethod\",\r\n                \"updateMethod\", \r\n                \"options\",\r\n                \"optionStyle\"\r\n            ]\r\n        }\r\n    },\r\n    \"form\": [\r\n        \"title\",\r\n\r\n        {\r\n            \"key\": \"retrieveMethod\",\r\n            \"type\": \"rc-select\",\r\n            \"multiple\": false,\r\n            \"items\": [\r\n                {\r\n                    \"value\": \"none\",\r\n                    \"label\": \"Don't retrieve\"\r\n                },\r\n                {\r\n                    \"value\": \"attribute\",\r\n                    \"label\": \"Subscribe for attribute\"\r\n                },\r\n                {\r\n                    \"value\": \"timeseries\",\r\n                    \"label\": \"Subscribe for timeseries\"\r\n                },\r\n                {\r\n                    \"value\": \"rpc\",\r\n                    \"label\": \"Call RPC get value method\"\r\n                }\r\n            ]\r\n        },\r\n        \"retrieveAttributeKey\",\r\n        \"retrieveRPCMethod\",\r\n        {\r\n            \"key\": \"parseValueFunction\",\r\n            \"type\": \"javascript\"\r\n        },\r\n        \r\n        {\r\n            \"key\": \"updateMethod\",\r\n            \"type\": \"rc-select\",\r\n            \"multiple\": false,\r\n            \"items\": [\r\n                {\r\n                    \"value\": \"SHARED_SCOPE\",\r\n                    \"label\": \"Update shared attribute\"\r\n                },\r\n                {\r\n                    \"value\": \"SERVER_SCOPE\",\r\n                    \"label\": \"Update server attribute\"\r\n                },\r\n                {\r\n                    \"value\": \"timeseries\",\r\n                    \"label\": \"Update timeseries\"\r\n                },\r\n                {\r\n                    \"value\": \"rpc\",\r\n                    \"label\": \"Call RPC set value method\"\r\n                }\r\n            ]\r\n        },\r\n        \"updateAttributeKey\",\r\n        \"updateRPCMethod\",\r\n        {\r\n            \"key\": \"convertValueFunction\",\r\n            \"type\": \"javascript\"\r\n        },\r\n        \r\n        \"requestTimeout\",\r\n        \r\n        {\r\n            \"key\": \"options\",\r\n            \"items\": [\r\n                \"options.trueLabel\",\r\n                \"options.falseLabel\"\r\n            ]\r\n        }, \r\n        {\r\n            \"key\": \"optionStyle\",\r\n            \"items\" :[\r\n                {\r\n                    \"key\": \"optionStyle.orientation\",\r\n                    \"type\": \"rc-select\",\r\n                    \"multiple\": false,\r\n                    \"items\": [{\r\n                        \"value\": \"column\",\r\n                        \"label\": \"Column\"\r\n                    }, {\r\n                        \"value\": \"row\",\r\n                        \"label\": \"Row\"\r\n                    }]\r\n                },\r\n                \"optionStyle.isRaised\",\r\n                {\r\n                    \"key\": \"optionStyle.checkedOption\",\r\n                    \"items\": [\r\n                        \"optionStyle.checkedOption.isPrimary\",\r\n                        {\r\n                            \"key\": \"optionStyle.checkedOption.bgColor\",\r\n                            \"type\": \"color\"\r\n                        },\r\n                        {\r\n                            \"key\": \"optionStyle.checkedOption.textColor\",\r\n                            \"type\": \"color\"\r\n                        }\r\n                    ]\r\n                }, {\r\n                    \"key\": \"optionStyle.uncheckedOption\",\r\n                    \"items\": [\r\n                        \"optionStyle.uncheckedOption.isPrimary\",\r\n                        {\r\n                            \"key\": \"optionStyle.uncheckedOption.bgColor\",\r\n                            \"type\": \"color\"\r\n                        },\r\n                        {\r\n                            \"key\": \"optionStyle.uncheckedOption.textColor\",\r\n                            \"type\": \"color\"\r\n                        }\r\n                    ]\r\n                }\r\n            ]\r\n        }\r\n    ]\r\n}",
        "dataKeySettingsSchema": "{}\r\n",
        "defaultConfig": "{\"showTitle\":true,\"backgroundColor\":\"#e6e7e8\",\"color\":\"rgba(0, 0, 0, 0.87)\",\"padding\":\"8px\",\"settings\":{\"optionStyle\":{\"orientation\":\"column\",\"isRaised\":true,\"checkedOption\":{\"isPrimary\":true},\"uncheckedOption\":{\"isPrimary\":false}},\"retrieveMethod\":\"rpc\",\"retrieveAttributeKey\":\"value\",\"retrieveRPCMethod\":\"getValue\",\"updateMethod\":\"rpc\",\"updateAttributeKey\":\"value\",\"updateRPCMethod\":\"setValue\",\"requestTimeout\":5000,\"parseValueFunction\":\"/* console.log(data); */\\n/* return data ? true : false; */\\nreturn data;\",\"convertValueFunction\":\"/* console.log(value); */\\n/* return value ? true : false; */\\nreturn value;\",\"options\":{\"trueLabel\":\"True label\",\"falseLabel\":\"False label\"}},\"title\":\"Segment switch of boolean value\",\"showTitleIcon\":false,\"titleIcon\":\"more_horiz\",\"iconColor\":\"rgba(0, 0, 0, 0.87)\",\"iconSize\":\"24px\",\"titleTooltip\":\"\",\"dropShadow\":true,\"enableFullscreen\":false,\"widgetStyle\":{},\"titleStyle\":{\"fontSize\":\"16px\",\"fontWeight\":400},\"useDashboardTimewindow\":true,\"displayTimewindow\":true,\"showLegend\":false,\"actions\":{},\"targetDeviceAliases\":[]}"
      }
    },
    {
      "alias": "select_double_value_from_flexiable_options",
      "name": "Select double value from flexiable options",
      "descriptor": {
        "type": "rpc",
        "sizeX": 7.5,
        "sizeY": 3,
        "resources": [],
        "templateHtml": "<div class=\"tb-rpc-button\" fxLayout=\"column\">\r\n    <div fxFlex=\"{{showTitle ? 20 : 0}}\" class=\"title-container\" fxLayout=\"row\"\r\n        fxLayoutAlign=\"center center\" [fxShow]=\"showTitle\">\r\n        <span class=\"button-title\">{{title}}</span>\r\n    </div>\r\n    <div fxFlex=\"{{showTitle ? 80 : 100}}\" [ngStyle]=\"{paddingTop: showTitle ? '5px': '5px'}\"\r\n        class=\"button-container\" fxLayout=\"column\" fxLayoutAlign=\"center center\"> \r\n\r\n\t\t\t<select [(ngModel)]=\"currentValue\" (change)=\"updateValue()\" \r\n\t\t\t\t[ngStyle]=\"customStyle\" \r\n\t\t\t\taria-label=\"Pick a value\" >\r\n\t\t\t\t\r\n                <option *ngFor=\"let x of options\" [value]=\"x.attributeValue\">\r\n                    {{x.optionLabel}}\r\n                </option>\r\n\t\t\t\t\r\n            </select>\r\n            \r\n    </div>\r\n    <div class=\"error-container\" [ngStyle]=\"{'background': error?.length ? 'rgba(255,255,255,0.25)' : 'none'}\"\r\n         fxLayout=\"row\" fxLayoutAlign=\"center center\">\r\n        <span class=\"button-error\">{{ error }}</span>\r\n    </div>\r\n</div>\r\n",
        "templateCss": ".tb-rpc-button {\r\n    width: 100%;\r\n    height: 100%;\r\n}\r\n\r\n.tb-rpc-button .title-container {\r\n    font-weight: 500;\r\n    white-space: nowrap;\r\n    margin: 10px 0;\r\n}\r\n\r\n.tb-rpc-button .button-container div{\r\n    min-width: 80%\r\n}\r\n\r\n.tb-rpc-button .button-container .mat-button{\r\n    width: 100%;\r\n    margin: 0;\r\n}\r\n\r\n.tb-rpc-button .button-container .mat-button{\r\n    padding: 0 4px;\r\n}\r\n\r\n.tb-rpc-button .error-container {\r\n    position: absolute;\r\n    top: 2%;\r\n    right: 0;\r\n    left: 0;\r\n    z-index: 4;\r\n    height: 14px;\r\n}\r\n\r\n.tb-rpc-button .error-container .button-error {\r\n    color: #ff3315;\r\n    white-space: nowrap;\r\n}",
        "controllerScript": "// Based on Segment switch of string value\r\n\r\nlet valueSubscription;\r\n\r\nself.onInit = function() {\r\n    self.ctx.ngZone.run(function() {\r\n       init();\r\n       self.ctx.detectChanges(true);\r\n    });\r\n};\r\n\r\n\r\n\r\nfunction init() {\r\n    let utils       = self.ctx.$scope.$injector.get(self.ctx.servicesMap.get('utils'));\r\n    //let types       = self.ctx.$scope.$injector.get(self.ctx.servicesMap.get('types'));\r\n    //let toast       = self.ctx.$scope.$injector.get(self.ctx.servicesMap.get('toast'));\r\n    let translate   = self.ctx.$scope.$injector.get(self.ctx.servicesMap.get('translate'));\r\n    //let $q          = self.ctx.$scope.$injector.get(self.ctx.servicesMap.get('$q'));\r\n    let http        = self.ctx.$scope.$injector.get(self.ctx.servicesMap.get('http'));\r\n    let attributeService = self.ctx.$scope.$injector.get(self.ctx.servicesMap.get('attributeService'));\r\n    let rpcUpdateStatus = {};\r\n    let settings = utils.deepClone(self.ctx.settings) || {}; \r\n    \r\n    self.ctx.$scope.toastTargetId = 'input-widget' + utils.guid();\r\n    self.ctx.$scope.showTitle = settings.title && settings.title.length ? true : false; ////utils.defaultValue(settings.title, true);\r\n    self.ctx.$scope.title = settings.title;\r\n    //self.ctx.$scope.options = settings.options;\r\n    self.ctx.$scope.options = [];\r\n    /*for (const item of timezones) {\r\n        self.ctx.$scope.options.push({\r\n            \"optionLabel\": item.name,\r\n            \"attributeValue\": item.offset\r\n        });\r\n    }*/\r\n    \r\n    //[ngStyle]=\"{'color': currentValue!==originalValue ? 'rgba(255,0,0,0.87)' : 'none'}\" \r\n    /*function refreshTextColor() {\r\n        if (self.ctx.$scope.currentValue!==self.ctx.$scope.originalValue) {\r\n            self.ctx.$scope.customStyle = {'color': 'rgba(255,0,0,0.87)'};\r\n        } else {\r\n            self.ctx.$scope.customStyle = {'color': 'none'};\r\n        }\r\n        console.log(\"refreshTextColor():\", self.ctx.$scope.currentValue, self.ctx.$scope.originalValue, self.ctx.$scope.customStyle);\r\n    };*/\r\n    \r\n    //console.log(\"onInit\", settings);\r\n    self.ctx.$scope.currentValue = self.ctx.$scope.originalValue = \"0\";\r\n    //refreshTextColor();\r\n    \r\n    let parseValueFunction = (data) => data;        // Retrieve data\r\n    if (settings.parseValueFunction && settings.parseValueFunction.length) {\r\n        try {\r\n            parseValueFunction = new Function('data', settings.parseValueFunction);\r\n        } catch (e) {\r\n            parseValueFunction = (data) => data;\r\n        }\r\n    }\r\n    \r\n    let convertValueFunction = (value) => value;    // Update data\r\n    if (settings.convertValueFunction && settings.convertValueFunction.length) {\r\n        try {\r\n            convertValueFunction = new Function('value', settings.convertValueFunction);\r\n        } catch (e) {\r\n            convertValueFunction = (value) => value;\r\n        }\r\n    }\r\n    \r\n    // subscribe attribute & timeseries \r\n    let retrieveAttributeKey            = settings.retrieveAttributeKey;\r\n    let retrieveAttributeKeyOfMinValue  = settings.retrieveAttributeKeyOfMinValue;\r\n    let retrieveAttributeKeyOfMaxValue  = settings.retrieveAttributeKeyOfMaxValue;\r\n    let retrieveAttributeKeyOfStepValue = settings.retrieveAttributeKeyOfStepValue;\r\n    let retrieveAttributeKeyOfUnit      = settings.retrieveAttributeKeyOfUnit;\r\n    let lastAttrValue;\r\n    let lastAttrValueOfMin;\r\n    let lastAttrValueOfMax;\r\n    let lastAttrValueOfStep;\r\n    let lastAttrValueOfUnit;\r\n    function onDataUpdatedForSubscribe(subscription, apply) {\r\n        let attrValue;\r\n        let attrValueOfMin;\r\n        let attrValueOfMax;\r\n        let attrValueOfStep;\r\n        let attrValueOfUnit;\r\n        \r\n        for (let i=0; subscription.data && i<subscription.data.length; i++) {\r\n            let keyName  = subscription.data[i].dataKey.name;\r\n            if (subscription.data[i].data && subscription.data[i].data.length>0) {\r\n                let KeyValue = subscription.data[i].data[0][1];\r\n                if (retrieveAttributeKey && keyName === retrieveAttributeKey) {\r\n                    /*try { \r\n                        attrValue = parseValueFunction(KeyValue);  ////angular.fromJson(newValue)\r\n                    } catch (e){\r\n                        self.ctx.$scope.error = 'parseValueFunction(value) error!'\r\n                    }*/\r\n                    if (typeof KeyValue === 'number' && isFinite(KeyValue)) {\r\n                        attrValue = KeyValue;\r\n                    }\r\n                    \r\n                } else if (retrieveAttributeKeyOfMinValue && keyName === retrieveAttributeKeyOfMinValue) {\r\n                    if (typeof KeyValue === 'number' && isFinite(KeyValue)) {\r\n                        attrValueOfMin = KeyValue;\r\n                    }\r\n    \r\n                } else if (retrieveAttributeKeyOfMaxValue && keyName === retrieveAttributeKeyOfMaxValue) {\r\n                    if (typeof KeyValue === 'number' && isFinite(KeyValue)) {\r\n                        attrValueOfMax = KeyValue;\r\n                    }\r\n    \r\n                } else if (retrieveAttributeKeyOfStepValue && keyName === retrieveAttributeKeyOfStepValue) {\r\n                    if (typeof KeyValue === 'number' && isFinite(KeyValue)) {\r\n                        attrValueOfStep = KeyValue;\r\n                    }\r\n    \r\n                } else if (retrieveAttributeKeyOfUnit && keyName === retrieveAttributeKeyOfUnit) {\r\n                    attrValueOfUnit = String(KeyValue);\r\n    \r\n                } else {\r\n                    console.log(\"unkown data:subscription.data[%d]\", i);\r\n                    console.log(subscription.data[i]);\r\n                }\r\n            }\r\n        }\r\n        \r\n        //console.log(attrValueOfMin, attrValueOfMax, attrValueOfStep, attrValueOfUnit, attrValue);\r\n        //console.log(lastAttrValueOfMin, lastAttrValueOfMax, lastAttrValueOfStep, lastAttrValueOfUnit);\r\n        if (attrValueOfMin !== lastAttrValueOfMin || attrValueOfMax !== lastAttrValueOfMax ||\r\n            attrValueOfStep !== lastAttrValueOfStep || attrValueOfUnit !== lastAttrValueOfUnit) {\r\n\r\n            if (attrValueOfMin)  lastAttrValueOfMin = attrValueOfMin;\r\n            if (attrValueOfMax)  lastAttrValueOfMax = attrValueOfMax;\r\n            if (attrValueOfStep) lastAttrValueOfStep = attrValueOfStep; \r\n            if (attrValueOfUnit) lastAttrValueOfUnit = attrValueOfUnit;\r\n            \r\n            if (attrValueOfMin && attrValueOfMax && attrValueOfStep) {\r\n                let factor = 100;\r\n                if (self.ctx.widgetConfig.decimals && self.ctx.widgetConfig.decimals>=0) {\r\n                    factor = Math.pow(10, self.ctx.widgetConfig.decimals);\r\n                }\r\n                \r\n                self.ctx.$scope.options = [];\r\n                let fMin = factor*attrValueOfMin;\r\n                let fMax = factor*attrValueOfMax;\r\n                let fStep = factor*attrValueOfStep;\r\n                for (let val=fMin, i=0; val<fMax+fStep; i++, val=fMin+fStep*i){\r\n                ////for (let val=factor*attrValueOfMin, i=0; val<factor*attrValueOfMax+factor*attrValueOfStep; i++, val=factor*attrValueOfMin+factor*attrValueOfStep*i){\r\n                    let attributeValue = val / factor;\r\n                    let optionLabel;\r\n                    if (self.ctx.widgetConfig.decimals && self.ctx.widgetConfig.decimals>=0) {\r\n                        optionLabel = attributeValue.toFixed(self.ctx.widgetConfig.decimals);\r\n                    } else {\r\n                        optionLabel = attributeValue.toString();\r\n                    }\r\n                    if (attrValueOfUnit && attrValueOfUnit.length) {\r\n                        optionLabel = optionLabel + \" \" + attrValueOfUnit;\r\n                    }\r\n                    let item = {\r\n                        \"optionLabel\" : optionLabel,\r\n                        \"attributeValue\" : String(attributeValue)\r\n                    };\r\n                    self.ctx.$scope.options.push(item);\r\n                }\r\n            }\r\n            \r\n        }\r\n        \r\n        if (attrValue) {\r\n            self.ctx.$scope.currentValue = self.ctx.$scope.originalValue = String(attrValue);\r\n            //refreshTextColor();\r\n        }\r\n        \r\n        if (apply) {\r\n            self.ctx.detectChanges(); //self.ctx.$scope.$digest();\r\n        }\r\n        \r\n        //console.log(\"onDataUpdatedForSubscribe():\", self.ctx.$scope.currentValue, self.ctx.$scope.originalValue, attrValue, apply);\r\n    }\r\n    function onDataUpdateErrorForSubscribe(subscription, e) {\r\n        var exceptionData = utils.parseException(e);\r\n        var errorText = exceptionData.name;\r\n        if (exceptionData.message) {\r\n            errorText += ': ' + exceptionData.message;\r\n        }\r\n        self.ctx.$scope.error = errorText;\r\n        console.log(\"onDataUpdateErrorForSubscribe(): errorText=\", errorText);\r\n    }\r\n    function subscribeAttributesOrTimeseries(type, entityType, entityId /*, retrieveMethod, key*/) {\r\n        var valueSubscriptionInfo = [{\r\n            type:       type,\r\n            entityType: entityType,\r\n            entityId:   entityId\r\n        }];\r\n        \r\n        ////if (retrieveMethod == 'attribute') {\r\n            ////valueSubscriptionInfo[0].attributes = [ {name: key}];\r\n            valueSubscriptionInfo[0].attributes = [];\r\n            if (retrieveAttributeKey && retrieveAttributeKey.length) {\r\n                valueSubscriptionInfo[0].attributes.push( { name: retrieveAttributeKey } );\r\n            }\r\n            if (retrieveAttributeKeyOfMinValue && retrieveAttributeKeyOfMinValue.length) {\r\n                valueSubscriptionInfo[0].attributes.push( { name: retrieveAttributeKeyOfMinValue } );\r\n            }\r\n            if (retrieveAttributeKeyOfMaxValue && retrieveAttributeKeyOfMaxValue.length) {\r\n                valueSubscriptionInfo[0].attributes.push( { name: retrieveAttributeKeyOfMaxValue } );\r\n            }\r\n            if (retrieveAttributeKeyOfStepValue && retrieveAttributeKeyOfStepValue.length) {\r\n                valueSubscriptionInfo[0].attributes.push( { name: retrieveAttributeKeyOfStepValue } );\r\n            }\r\n            if (retrieveAttributeKeyOfUnit && retrieveAttributeKeyOfUnit.length) {\r\n                valueSubscriptionInfo[0].attributes.push( { name: retrieveAttributeKeyOfUnit } );\r\n            }\r\n        ////} else {\r\n        ////    valueSubscriptionInfo[0].timeseries = [{name: key}];\r\n        ////}\r\n        \r\n        var subscriptionOptions = {\r\n            callbacks: {\r\n                onDataUpdated: onDataUpdatedForSubscribe,\r\n                onDataUpdateError: onDataUpdateErrorForSubscribe\r\n            }\r\n        };\r\n        self.ctx.subscriptionApi.createSubscriptionFromInfo (\r\n            'latest', valueSubscriptionInfo, subscriptionOptions, false, true).subscribe( //types.widgetType.latest.value\r\n            (subscription) => {\r\n                valueSubscription = subscription;\r\n            }\r\n        );    \r\n    }\r\n    \r\n    // update attribute\r\n    function updateAttributes(entityType, entityId, attributeScope, key, value) { \r\n        let attributes = [];\r\n        attributes.push({\r\n            \"key\": key,                             // attribute name,\r\n            \"value\": convertValueFunction(value)    // attribute value\r\n        });\r\n\r\n        ////attributeService.saveEntityAttributes(self.ctx.datasources[0].entityType, self.ctx.datasources[0].entityId,\r\n        attributeService.saveEntityAttributes({\"entityType\":entityType, \"id\":entityId}, \r\n            attributeScope, attributes).subscribe(\r\n            function success() {\r\n                retrieveValue();  //self.ctx.$scope.originalValue = self.ctx.$scope.currentValue = value;\r\n                self.ctx.$scope.error = \"\";\r\n            },\r\n            function fail(rejection) {\r\n                var errorText = rejection.status + \": \" + rejection.statusText;\r\n                if (self.ctx.settings.showError) {\r\n                    self.ctx.$scope.error =errorText\r\n                        \r\n                }\r\n                console.log(\"updateAttributes(): errorText=\", errorText);\r\n            }\r\n        );\r\n    }\r\n    \r\n    // update timeseries \r\n    function saveEntityTimeseries(entityType, entityId, telemetries) {\r\n        var telemetriesData = {};\r\n        for (var a = 0; a < telemetries.length; a++) {\r\n            if (typeof telemetries[a].value !== 'undefined' && telemetries[a].value !== null) {\r\n                telemetriesData[telemetries[a].key] = telemetries[a].value;\r\n            }\r\n        }\r\n        if (Object.keys(telemetriesData).length) {\r\n            var url = '/api/plugins/telemetry/' + entityType + '/' + entityId + '/timeseries/scope';\r\n            return http.post(url, telemetriesData);\r\n        }\r\n        return null;\r\n    }\r\n    function updateTimeseries(entityType, entityId, key, value) {\r\n        //var datasource = self.ctx.datasources[0];\r\n        let observable = saveEntityTimeseries(\r\n            entityType,     // datasource.entityType,\r\n            entityId,       // datasource.entityId,\r\n            [\r\n                {\r\n                    key: key,\r\n                    value: convertValueFunction(value)\r\n                }\r\n            ]\r\n        );\r\n        if (observable) {\r\n            observable.subscribe(\r\n                function success() {\r\n                    /*if (settings.showResultMessage) {\r\n                        $scope.showSuccessToast(translate.instant('widgets.input-widgets.update-successful'), 1000, 'bottom', 'left', $scope.toastTargetId);\r\n                    }*/\r\n                    retrieveValue();    //$scope.originalValue = $scope.currentValue = value;\r\n                },\r\n                function fail() {\r\n                    /*if (settings.showResultMessage) {\r\n                        $scope.showErrorToast(translate.instant('widgets.input-widgets.update-failed'), 'bottom', 'left', $scope.toastTargetId);\r\n                    }*/\r\n                var errorText = $translate.instant('widgets.input-widgets.update-failed');\r\n                self.ctx.$scope.error = errorText;\r\n                console.log(\"updateTimeseries(): errorText=\", errorText);\r\n                }\r\n            );\r\n        }\r\n    }\r\n\r\n    // RPC retrieve value\r\n    /*function rpcRetrieveValue(method, timeout) {\r\n        if (method && method.length) {\r\n            self.ctx.$scope.error = '';\r\n            self.ctx.controlApi.sendTwoWayCommand(method, null, timeout).subscribe(\r\n                function success(responseBody) {\r\n                    ////self.ctx.$scope.currentValue = self.ctx.$scope.originalValue = responseBody;\r\n                    self.ctx.$scope.currentValue = self.ctx.$scope.originalValue = parseValueFunction(responseBody);\r\n\r\n                    ////self.ctx.$scope.$digest(); // Error: $digest already in progress\r\n                },\r\n                function fail() {\r\n                    self.ctx.$scope.error = self.ctx.defaultSubscription.rpcErrorText;\r\n                }\r\n            );\r\n        } else {\r\n            self.ctx.$scope.error = \"retrieveRPCMethod is null.\";\r\n        }\r\n    }*/\r\n    // RPC update value\r\n    function rpcUpdateValue(method, value, timeout) {\r\n        if (rpcUpdateStatus.executingUpdateValue) {\r\n            rpcUpdateStatus.scheduledValue = value;\r\n            return;\r\n        } else {\r\n            rpcUpdateStatus.scheduledValue = null;\r\n            rpcUpdateStatus.rpcValue = value;\r\n            rpcUpdateStatus.executingUpdateValue = true;\r\n        }\r\n        self.ctx.$scope.error = '';\r\n        self.ctx.controlApi.sendOneWayCommand(method, convertValueFunction(value), timeout).subscribe(\r\n            () => {\r\n                rpcUpdateStatus.executingUpdateValue = false;\r\n                if (rpcUpdateStatus.scheduledValue !== null && rpcUpdateStatus.scheduledValue != rpcUpdateStatus.rpcValue) {\r\n                    rpcUpdateValue(rpcUpdateStatus.scheduledValue);\r\n                } else {\r\n                    retrieveValue(); // self.ctx.$scope.originalValue = self.ctx.$scope.currentValue = value;\r\n                }\r\n            },\r\n            () => {\r\n                rpcUpdateStatus.executingUpdateValue = false;\r\n                self.ctx.$scope.error = self.ctx.defaultSubscription.rpcErrorText;\r\n                console.log(\"rpcUpdateValue(): errorText=\", self.ctx.$scope.error);\r\n            }\r\n        );\r\n    }\r\n\r\n    // update value\r\n    self.ctx.$scope.updateValue = function() {\r\n        //refreshTextColor();\r\n        \r\n        var newValue = self.ctx.$scope.currentValue * 1;\r\n        console.log(\"updateValue():\", self.ctx.$scope.currentValue, newValue);\r\n\r\n        if (settings.updateMethod === \"SHARED_SCOPE\" || settings.updateMethod === \"SERVER_SCOPE\") {\r\n            updateAttributes(\"DEVICE\", //types.entityType.device, \r\n                self.ctx.defaultSubscription.targetDeviceId, \r\n                settings.updateMethod, \r\n                settings.updateAttributeKey, \r\n                newValue);\r\n                \r\n        } else if (settings.updateMethod === \"timeseries\") {\r\n            updateTimeseries(\"DEVICE\", // types.entityType.device,  types.constant.js\r\n                self.ctx.defaultSubscription.targetDeviceId, \r\n                settings.updateAttributeKey, \r\n                newValue);\r\n                \r\n        } else if (settings.updateMethod === \"rpc\") {\r\n            rpcUpdateValue(settings.updateRPCMethod, \r\n                newValue, \r\n                settings.requestTimeout);\r\n            \r\n        } else {\r\n            self.ctx.$scope.error = \"updateMethod is error!\";\r\n\r\n        }\r\n    }\r\n\r\n    // retrieve value\r\n    var firstRetrieveValue = true;\r\n    function retrieveValue() {\r\n        let rpcEnabled = self.ctx.defaultSubscription.rpcEnabled;\r\n        let isSimulated = self.ctx.$scope.widgetEditMode;\r\n        if (!rpcEnabled) {\r\n            self.ctx.$scope.error = 'Target device is not set!';\r\n        } else {\r\n            if (!isSimulated) {\r\n                ////if (settings.retrieveMethod == 'rpc') {\r\n                ////    rpcRetrieveValue(settings.retrieveRPCMethod, settings.requestTimeout);\r\n                ////} else if (settings.retrieveMethod == 'attribute' || settings.retrieveMethod == 'timeseries') {\r\n                    if (firstRetrieveValue) {\r\n                        subscribeAttributesOrTimeseries(\"entity\", // types.datasourceType.entity, in types.constant.js\r\n                            \"DEVICE\", //types.entityType.device, in types.constant.js\r\n                            self.ctx.defaultSubscription.targetDeviceId/*, \r\n                            settings.retrieveMethod, \r\n                            settings.retrieveAttributeKey*/);\r\n                    }\r\n                ////}\r\n            } \r\n        }\r\n        \r\n        firstRetrieveValue = false;\r\n    }\r\n    \r\n    retrieveValue();\r\n};\r\n\r\nself.onResize = function() {\r\n};\r\n\r\nself.onDestory = function() {\r\n    if (valueSubscription) {\r\n        self.ctx.subscriptionApi.removeSubscription(valueSubscription.id);\r\n    }\r\n};\r\n\r\n/*self.onDataUpdated = function() {\r\n    try{\r\n        self.ctx.$scope.currentValue = self.ctx.$scope.originalValue = self.ctx.data[0].data[0][1];\r\n        self.ctx.$scope.$digest();\r\n    } catch (e) {\r\n        console.log(e);\r\n    }\r\n}*/\r\n\r\n/*self.typeParameters = function() {\r\n    return {\r\n        maxDatasources: 1, // Maximum allowed datasources for this widget, -1 - unlimited\r\n        maxDataKeys: 1 //Maximum allowed data keys for this widget, -1 - unlimited\r\n    }\r\n};*/\r\n\r\n\r\n/*\"retrieveMethod\": {\r\n    \"title\": \"Retrieve double value using method\",\r\n    \"type\": \"string\",\r\n    \"default\": \"rpc\"\r\n},\r\n\"retrieveAttributeKey\": {\r\n    \"title\": \"Retrieve Attribute/Timeseries value key (only when subscribe for attribute/timeseries method)\",\r\n    \"type\": \"string\",\r\n    \"default\": \"\"\r\n},\r\n\"retrieveRPCMethod\": {\r\n    \"title\": \"Retrieve value using RPC method (only when call RPC get value method)\",\r\n    \"type\": \"string\",\r\n    \"default\": \"\"\r\n},\r\n\"parseValueFunction\": {\r\n    \"title\": \"Parse value function, f(data), returns double value\",\r\n    \"type\": \"string\",\r\n    \"default\": \"return data; \"\r\n},\r\n----------------------------------------------------------\r\n{\r\n            \"key\": \"retrieveMethod\",\r\n            \"type\": \"rc-select\",\r\n            \"multiple\": false,\r\n            \"items\": [\r\n                {\r\n                    \"value\": \"none\",\r\n                    \"label\": \"Don't retrieve\"\r\n                },\r\n                {\r\n                    \"value\": \"attribute\",\r\n                    \"label\": \"Subscribe for attribute\"\r\n                },\r\n                {\r\n                    \"value\": \"timeseries\",\r\n                    \"label\": \"Subscribe for timeseries\"\r\n                },\r\n                {\r\n                    \"value\": \"rpc\",\r\n                    \"label\": \"Call RPC get value method\"\r\n                }\r\n            ]\r\n        },\r\n        \"retrieveAttributeKey\",\r\n        \"retrieveRPCMethod\",\r\n        {\r\n            \"key\": \"parseValueFunction\",\r\n            \"type\": \"javascript\"\r\n        },\r\n\r\n*/\r\n",
        "settingsSchema": "{\n    \"schema\": {\n        \"type\": \"object\",\n        \"title\": \"Settings\",\n        \"properties\": {\n            \"title\": {\n                \"title\": \"Widget title\",\n                \"type\": \"string\",\n                \"default\": \"\"\n            },\n            \n            \"retrieveAttributeKey\": {\n                \"title\": \"Device attribute key\",\n                \"type\": \"string\",\n                \"default\": \"\"\n            },\n            \"retrieveAttributeKeyOfMinValue\": {\n                \"title\": \"Device attribute key of Min value\",\n                \"type\": \"string\",\n                \"default\": \"\"\n            },\n            \"retrieveAttributeKeyOfMaxValue\": {\n                \"title\": \"Device attribute key of Max value\",\n                \"type\": \"string\",\n                \"default\": \"\"\n            },\n            \"retrieveAttributeKeyOfStepValue\": {\n                \"title\": \"Device attribute key of Step value\",\n                \"type\": \"string\",\n                \"default\": \"\"\n            },\n            \"retrieveAttributeKeyOfUnit\": {\n                \"title\": \"Device attribute key of Unit\",\n                \"type\": \"string\",\n                \"default\": \"\"\n            },\n            \n            \"updateMethod\": {\n                \"title\": \"Update double value using method\",\n                \"type\": \"string\",\n                \"default\": \"rpc\"\n            },\n            \"updateAttributeKey\": {\n                \"title\": \"Update Attribute/Timeseries value key (only when update for attribute/timeseries method)\",\n                \"type\": \"string\",\n                \"default\": \"\"\n            },\n            \"updateRPCMethod\": {\n                \"title\": \"Update value using RPC method (only when call RPC set value method)\",\n                \"type\": \"string\",\n                \"default\": \"\"\n            },\n            \"convertValueFunction\": {\n                \"title\": \"Convert value function, f(value), returns payload used by RPC set value method\",\n                \"type\": \"string\",\n                \"default\": \"return value; /* console.log(value); */\"\n            },\n\n            \"requestTimeout\": {\n                \"title\": \"RPC request timeout\",\n                \"type\": \"number\",\n                \"default\": 5000\n            },\n\n            \"required\": [\n                \"retrieveAttributeKey\",\n                \"retrieveAttributeKeyOfMinValue\",\n                \"retrieveAttributeKeyOfMaxValue\",\n                \"retrieveAttributeKeyOfStepValue\",\n                \"updateMethod\"\n            ]\n        }\n    },\n    \"form\": [\n        \"title\",\n\n        \"retrieveAttributeKey\",\n        \"retrieveAttributeKeyOfMinValue\",\n        \"retrieveAttributeKeyOfMaxValue\",\n        \"retrieveAttributeKeyOfStepValue\",\n        \"retrieveAttributeKeyOfUnit\",\n        \n        {\n            \"key\": \"updateMethod\",\n            \"type\": \"rc-select\",\n            \"multiple\": false,\n            \"items\": [\n                {\n                    \"value\": \"SHARED_SCOPE\",\n                    \"label\": \"Update shared attribute\"\n                },\n                {\n                    \"value\": \"SERVER_SCOPE\",\n                    \"label\": \"Update server attribute\"\n                },\n                {\n                    \"value\": \"timeseries\",\n                    \"label\": \"Update timeseries\"\n                },\n                {\n                    \"value\": \"rpc\",\n                    \"label\": \"Call RPC set value method\"\n                }\n            ]\n        },\n        \"updateAttributeKey\",\n        \"updateRPCMethod\",\n        {\n            \"key\": \"convertValueFunction\",\n            \"type\": \"javascript\"\n        },\n        \n        \"requestTimeout\"\n    ]\n}",
        "dataKeySettingsSchema": "{}\r\n",
        "defaultConfig": "{\"showTitle\":true,\"backgroundColor\":\"#e6e7e8\",\"color\":\"rgba(0, 0, 0, 0.87)\",\"padding\":\"8px\",\"settings\":{\"optionStyle\":{\"orientation\":\"column\",\"isRaised\":true,\"checkedOption\":{\"isPrimary\":true},\"uncheckedOption\":{\"isPrimary\":false}},\"options\":[{\"optionLabel\":\"Option1 Label\",\"attributeValue\":\"option1\"},{\"optionLabel\":\"Option2 Label\",\"attributeValue\":\"option2\"}],\"retrieveMethod\":\"rpc\",\"retrieveAttributeKey\":\"value\",\"retrieveRPCMethod\":\"getValue\",\"parseValueFunction\":\"/* console.log(data); */\\nreturn data;\",\"updateMethod\":\"rpc\",\"updateAttributeKey\":\"value\",\"updateRPCMethod\":\"setValue\",\"convertValueFunction\":\"/* console.log(value); */\\nreturn value;\",\"requestTimeout\":5000},\"title\":\"Select double value from flexiable options\",\"showTitleIcon\":false,\"titleIcon\":\"more_horiz\",\"iconColor\":\"rgba(0, 0, 0, 0.87)\",\"iconSize\":\"24px\",\"titleTooltip\":\"\",\"dropShadow\":true,\"enableFullscreen\":false,\"widgetStyle\":{},\"titleStyle\":{\"fontSize\":\"16px\",\"fontWeight\":400},\"useDashboardTimewindow\":true,\"displayTimewindow\":true,\"showLegend\":false,\"actions\":{},\"targetDeviceAliases\":[]}"
      }
    },
    {
      "alias": "select_timezone_value",
      "name": "Select timezone value",
      "descriptor": {
        "type": "rpc",
        "sizeX": 7.5,
        "sizeY": 3,
        "resources": [],
        "templateHtml": "<div class=\"tb-rpc-button\" fxLayout=\"column\">\r\n    <div fxFlex=\"{{showTitle ? 20 : 0}}\" class=\"title-container\" fxLayout=\"row\"\r\n        fxLayoutAlign=\"center center\" [fxShow]=\"showTitle\">\r\n        <span class=\"button-title\">{{title}}</span>\r\n    </div>\r\n    <div fxFlex=\"{{showTitle ? 80 : 100}}\" [ngStyle]=\"{paddingTop: showTitle ? '5px': '5px'}\"\r\n        class=\"button-container\" fxLayout=\"column\" fxLayoutAlign=\"center center\"> \r\n\r\n\t\t\t<select [(ngModel)]=\"currentValue\" (change)=\"updateValue()\" \r\n\t\t\t\t[ngStyle]=\"customStyle\" \r\n\t\t\t\taria-label=\"Pick a value\" >\r\n\t\t\t\t\r\n                <option *ngFor=\"let x of options\" [value]=\"x.attributeValue\">\r\n                    {{x.optionLabel}}\r\n                </option>\r\n\t\t\t\t\r\n            </select>\r\n            \r\n    </div>\r\n    <div class=\"error-container\" [ngStyle]=\"{'background': error?.length ? 'rgba(255,255,255,0.25)' : 'none'}\"\r\n         fxLayout=\"row\" fxLayoutAlign=\"center center\">\r\n        <span class=\"button-error\">{{ error }}</span>\r\n    </div>\r\n</div>\r\n",
        "templateCss": ".tb-rpc-button {\r\n    width: 100%;\r\n    height: 100%;\r\n}\r\n\r\n.tb-rpc-button .title-container {\r\n    font-weight: 500;\r\n    white-space: nowrap;\r\n    margin: 10px 0;\r\n}\r\n\r\n.tb-rpc-button .button-container div{\r\n    min-width: 80%\r\n}\r\n\r\n.tb-rpc-button .button-container .mat-button{\r\n    width: 100%;\r\n    margin: 0;\r\n}\r\n\r\n.tb-rpc-button .button-container .mat-button{\r\n    padding: 0 4px;\r\n}\r\n\r\n.tb-rpc-button .error-container {\r\n    position: absolute;\r\n    top: 2%;\r\n    right: 0;\r\n    left: 0;\r\n    z-index: 4;\r\n    height: 14px;\r\n}\r\n\r\n.tb-rpc-button .error-container .button-error {\r\n    color: #ff3315;\r\n    white-space: nowrap;\r\n}",
        "controllerScript": "// Based on Segment switch of string value\r\n\r\nlet valueSubscription;\r\n\r\n//[ngStyle]=\"{'color': currentValue!==originalValue ? 'rgba(255,0,0,0.87)' : 'none'}\"\r\n\r\nlet timezones = [   {\"name\":\"UTC-12:00\", \"offset\": -(12*60)},\r\n                    {\"name\":\"UTC-11:00\", \"offset\": -(11*60)},\r\n                    {\"name\":\"UTC-10:00\", \"offset\": -(10*60)},\r\n                    {\"name\":\"UTC-09:30\", \"offset\": -( 9*60 + 30)},\r\n                    {\"name\":\"UTC-09:00\", \"offset\": -( 9*60)},\r\n                    {\"name\":\"UTC-08:00\", \"offset\": -( 8*60)},\r\n                    {\"name\":\"UTC-07:00\", \"offset\": -( 7*60)},\r\n                    {\"name\":\"UTC-06:00\", \"offset\": -( 6*60)},\r\n                    {\"name\":\"UTC-05:00\", \"offset\": -( 5*60)},\r\n                    {\"name\":\"UTC-04:00\", \"offset\": -( 4*60)},\r\n                    {\"name\":\"UTC-03:30\", \"offset\": -( 3*60 + 30)},\r\n                    {\"name\":\"UTC-03:00\", \"offset\": -( 3*60)},\r\n                    {\"name\":\"UTC-02:00\", \"offset\": -( 2*60)},\r\n                    {\"name\":\"UTC-01:00\", \"offset\": -( 1*60)},\r\n                    {\"name\":\"UTC\",       \"offset\":  ( 0*60)},\r\n                    {\"name\":\"UTC+00:00\", \"offset\":  ( 0*60)},\r\n                    {\"name\":\"UTC+01:00\", \"offset\":  ( 1*60)},\r\n                    {\"name\":\"UTC+02:00\", \"offset\":  ( 2*60)},\r\n                    {\"name\":\"UTC+03:00\", \"offset\":  ( 3*60)},\r\n                    {\"name\":\"UTC+03:30\", \"offset\":  ( 3*60 + 30)},\r\n                    {\"name\":\"UTC+04:00\", \"offset\":  ( 4*60)},\r\n                    {\"name\":\"UTC+04:30\", \"offset\":  ( 4*60 + 30)},\r\n                    {\"name\":\"UTC+05:00\", \"offset\":  ( 5*60)},\r\n                    {\"name\":\"UTC+05:30\", \"offset\":  ( 5*60 + 30)},\r\n                    {\"name\":\"UTC+06:00\", \"offset\":  ( 6*60)},\r\n                    {\"name\":\"UTC+06:30\", \"offset\":  ( 6*60 + 30)},\r\n                    {\"name\":\"UTC+07:00\", \"offset\":  ( 7*60)},\r\n                    {\"name\":\"UTC+08:00\", \"offset\":  ( 8*60)},\r\n                    {\"name\":\"UTC+09:00\", \"offset\":  ( 9*60)},\r\n                    {\"name\":\"UTC+09:30\", \"offset\":  ( 9*60 + 30)},\r\n                    {\"name\":\"UTC+10:00\", \"offset\":  (10*60)},\r\n                    {\"name\":\"UTC+10:30\", \"offset\":  (10*60 + 30)},\r\n                    {\"name\":\"UTC+11:00\", \"offset\":  (11*60)},\r\n                    {\"name\":\"UTC+12:00\", \"offset\":  (12*60)},\r\n                    {\"name\":\"UTC+12:45\", \"offset\":  (12*60 + 45)},\r\n                    {\"name\":\"UTC+13:00\", \"offset\":  (13*60)},\r\n                    {\"name\":\"UTC+14:00\", \"offset\":  (14*60)},\r\n                ];\r\n\r\nself.onInit = function() {\r\n    self.ctx.ngZone.run(function() {\r\n       init();\r\n       self.ctx.detectChanges(true);\r\n    });\r\n};\r\n\r\n\r\n\r\nfunction init() {\r\n    let utils       = self.ctx.$scope.$injector.get(self.ctx.servicesMap.get('utils'));\r\n    //let types       = self.ctx.$scope.$injector.get(self.ctx.servicesMap.get('types'));\r\n    //let toast       = self.ctx.$scope.$injector.get(self.ctx.servicesMap.get('toast'));\r\n    let translate   = self.ctx.$scope.$injector.get(self.ctx.servicesMap.get('translate'));\r\n    //let $q          = self.ctx.$scope.$injector.get(self.ctx.servicesMap.get('$q'));\r\n    let http        = self.ctx.$scope.$injector.get(self.ctx.servicesMap.get('http'));\r\n    let attributeService = self.ctx.$scope.$injector.get(self.ctx.servicesMap.get('attributeService'));\r\n    let rpcUpdateStatus = {};\r\n    let settings = utils.deepClone(self.ctx.settings) || {}; \r\n    \r\n    self.ctx.$scope.toastTargetId = 'input-widget' + utils.guid();\r\n    self.ctx.$scope.showTitle = settings.title && settings.title.length ? true : false; ////utils.defaultValue(settings.title, true);\r\n    self.ctx.$scope.title = settings.title;\r\n    //self.ctx.$scope.options = settings.options;\r\n    self.ctx.$scope.options = [];\r\n    for (const item of timezones) {\r\n        self.ctx.$scope.options.push({\r\n            \"optionLabel\": item.name,\r\n            \"attributeValue\": item.offset\r\n        });\r\n    }\r\n    \r\n    let parseValueFunction = (data) => data;        // Retrieve data\r\n    if (settings.parseValueFunction && settings.parseValueFunction.length) {\r\n        try {\r\n            parseValueFunction = new Function('data', settings.parseValueFunction);\r\n        } catch (e) {\r\n            parseValueFunction = (data) => data;\r\n        }\r\n    }\r\n    \r\n    let convertValueFunction = (value) => value;    // Update data\r\n    if (settings.convertValueFunction && settings.convertValueFunction.length) {\r\n        try {\r\n            convertValueFunction = new Function('value', settings.convertValueFunction);\r\n        } catch (e) {\r\n            convertValueFunction = (value) => value;\r\n        }\r\n    }\r\n\r\n    // subscribe attribute & timeseries \r\n    function onDataUpdatedForSubscribe(subscription, apply) {\r\n        if (subscription.data.length) {\r\n            var keyData = subscription.data[0];\r\n            if (keyData && keyData.data && keyData.data[0]) {\r\n                var attrValue = keyData.data[0][1];\r\n                if (attrValue) {\r\n                    try {\r\n                        self.ctx.$scope.currentValue = self.ctx.$scope.originalValue = parseValueFunction(attrValue);  ////angular.fromJson(attrValue)\r\n                    } catch (e){\r\n                        self.ctx.$scope.error = 'parseValueFunction(value) error!';\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        \r\n        if (apply) {\r\n            self.ctx.detectChanges(); //self.ctx.$scope.$digest();\r\n        }\r\n    }\r\n    function onDataUpdateErrorForSubscribe(subscription, e) {\r\n        var exceptionData = utils.parseException(e);\r\n        var errorText = exceptionData.name;\r\n        if (exceptionData.message) {\r\n            errorText += ': ' + exceptionData.message;\r\n        }\r\n        self.ctx.$scope.error = errorText;\r\n        console.log(\"onDataUpdateErrorForSubscribe(): errorText=\", errorText);\r\n    }\r\n    function subscribeAttributesOrTimeseries(type, entityType, entityId, retrieveMethod, key) {\r\n        var valueSubscriptionInfo = [{\r\n            type:       type,\r\n            entityType: entityType,\r\n            entityId:   entityId\r\n        }];\r\n        \r\n        if (retrieveMethod == 'attribute') {\r\n            valueSubscriptionInfo[0].attributes = [\r\n                {name: key}\r\n            ];\r\n        } else {\r\n            valueSubscriptionInfo[0].timeseries = [\r\n                {name: key}\r\n            ];\r\n        }\r\n        \r\n        var subscriptionOptions = {\r\n            callbacks: {\r\n                onDataUpdated: onDataUpdatedForSubscribe,\r\n                onDataUpdateError: onDataUpdateErrorForSubscribe\r\n            }\r\n        };\r\n        self.ctx.subscriptionApi.createSubscriptionFromInfo (\r\n            'latest', valueSubscriptionInfo, subscriptionOptions, false, true).subscribe( //types.widgetType.latest.value\r\n            (subscription) => {\r\n                valueSubscription = subscription;\r\n            }\r\n        );    \r\n    }\r\n    \r\n    // update attribute\r\n    function updateAttributes(entityType, entityId, attributeScope, key, value) { \r\n        let attributes = [];\r\n        attributes.push({\r\n            \"key\": key,                             // attribute name,\r\n            \"value\": convertValueFunction(value)    // attribute value\r\n        });\r\n\r\n        ////attributeService.saveEntityAttributes(self.ctx.datasources[0].entityType, self.ctx.datasources[0].entityId,\r\n        attributeService.saveEntityAttributes({\"entityType\":entityType, \"id\":entityId}, \r\n            attributeScope, attributes).subscribe(\r\n            function success() {\r\n                retrieveValue();  //self.ctx.$scope.originalValue = self.ctx.$scope.currentValue = value;\r\n                self.ctx.$scope.error = \"\";\r\n            },\r\n            function fail(rejection) {\r\n                var errorText = rejection.status + \": \" + rejection.statusText;\r\n                if (self.ctx.settings.showError) {\r\n                    self.ctx.$scope.error =errorText\r\n                        \r\n                }\r\n                console.log(\"updateAttributes(): errorText=\", errorText);\r\n            }\r\n        );\r\n    }\r\n    \r\n    // update timeseries \r\n    function saveEntityTimeseries(entityType, entityId, telemetries) {\r\n        var telemetriesData = {};\r\n        for (var a = 0; a < telemetries.length; a++) {\r\n            if (typeof telemetries[a].value !== 'undefined' && telemetries[a].value !== null) {\r\n                telemetriesData[telemetries[a].key] = telemetries[a].value;\r\n            }\r\n        }\r\n        if (Object.keys(telemetriesData).length) {\r\n            var url = '/api/plugins/telemetry/' + entityType + '/' + entityId + '/timeseries/scope';\r\n            return http.post(url, telemetriesData);\r\n        }\r\n        return null;\r\n    }\r\n    function updateTimeseries(entityType, entityId, key, value) {\r\n        //var datasource = self.ctx.datasources[0];\r\n        let observable = saveEntityTimeseries(\r\n            entityType,     // datasource.entityType,\r\n            entityId,       // datasource.entityId,\r\n            [\r\n                {\r\n                    key: key,\r\n                    value: convertValueFunction(value)\r\n                }\r\n            ]\r\n        );\r\n        if (observable) {\r\n            observable.subscribe(\r\n                function success() {\r\n                    /*if (settings.showResultMessage) {\r\n                        $scope.showSuccessToast(translate.instant('widgets.input-widgets.update-successful'), 1000, 'bottom', 'left', $scope.toastTargetId);\r\n                    }*/\r\n                    retrieveValue();    //$scope.originalValue = $scope.currentValue = value;\r\n                },\r\n                function fail() {\r\n                    /*if (settings.showResultMessage) {\r\n                        $scope.showErrorToast(translate.instant('widgets.input-widgets.update-failed'), 'bottom', 'left', $scope.toastTargetId);\r\n                    }*/\r\n                var errorText = $translate.instant('widgets.input-widgets.update-failed');\r\n                self.ctx.$scope.error = errorText;\r\n                console.log(\"updateTimeseries(): errorText=\", errorText);\r\n                }\r\n            );\r\n        }\r\n    }\r\n\r\n    // RPC retrieve value\r\n    function rpcRetrieveValue(method, timeout) {\r\n        if (method && method.length) {\r\n            self.ctx.$scope.error = '';\r\n            self.ctx.controlApi.sendTwoWayCommand(method, null, timeout).subscribe(\r\n                function success(responseBody) {\r\n                    ////self.ctx.$scope.currentValue = self.ctx.$scope.originalValue = responseBody;\r\n                    self.ctx.$scope.currentValue = self.ctx.$scope.originalValue = parseValueFunction(responseBody);\r\n\r\n                    ////self.ctx.$scope.$digest(); // Error: $digest already in progress\r\n                },\r\n                function fail() {\r\n                    self.ctx.$scope.error = self.ctx.defaultSubscription.rpcErrorText;\r\n                }\r\n            );\r\n        } else {\r\n            self.ctx.$scope.error = \"retrieveRPCMethod is null.\";\r\n        }\r\n    }\r\n    // RPC update value\r\n    function rpcUpdateValue(method, value, timeout) {\r\n        if (rpcUpdateStatus.executingUpdateValue) {\r\n            rpcUpdateStatus.scheduledValue = value;\r\n            return;\r\n        } else {\r\n            rpcUpdateStatus.scheduledValue = null;\r\n            rpcUpdateStatus.rpcValue = value;\r\n            rpcUpdateStatus.executingUpdateValue = true;\r\n        }\r\n        self.ctx.$scope.error = '';\r\n        self.ctx.controlApi.sendOneWayCommand(method, convertValueFunction(value), timeout).subscribe(\r\n            () => {\r\n                rpcUpdateStatus.executingUpdateValue = false;\r\n                if (rpcUpdateStatus.scheduledValue !== null && rpcUpdateStatus.scheduledValue != rpcUpdateStatus.rpcValue) {\r\n                    rpcUpdateValue(rpcUpdateStatus.scheduledValue);\r\n                } else {\r\n                    retrieveValue(); // self.ctx.$scope.originalValue = self.ctx.$scope.currentValue = value;\r\n                }\r\n            },\r\n            () => {\r\n                rpcUpdateStatus.executingUpdateValue = false;\r\n                self.ctx.$scope.error = self.ctx.defaultSubscription.rpcErrorText;\r\n                console.log(\"rpcUpdateValue(): errorText=\", self.ctx.$scope.error);\r\n            }\r\n        );\r\n    }\r\n\r\n    // update value\r\n    self.ctx.$scope.updateValue = function() {\r\n        var newValue = self.ctx.$scope.currentValue * 1;\r\n\r\n        if (settings.updateMethod === \"SHARED_SCOPE\" || settings.updateMethod === \"SERVER_SCOPE\") {\r\n            updateAttributes(\"DEVICE\", //types.entityType.device, \r\n                self.ctx.defaultSubscription.targetDeviceId, \r\n                settings.updateMethod, \r\n                settings.updateAttributeKey, \r\n                newValue);\r\n                \r\n        } else if (settings.updateMethod === \"timeseries\") {\r\n            updateTimeseries(\"DEVICE\", // types.entityType.device,  types.constant.js\r\n                self.ctx.defaultSubscription.targetDeviceId, \r\n                settings.updateAttributeKey, \r\n                newValue);\r\n                \r\n        } else if (settings.updateMethod === \"rpc\") {\r\n            rpcUpdateValue(settings.updateRPCMethod, \r\n                newValue, \r\n                settings.requestTimeout);\r\n            \r\n        } else {\r\n            self.ctx.$scope.error = \"updateMethod is error!\";\r\n\r\n        }\r\n    }\r\n\r\n    // retrieve value\r\n    var firstRetrieveValue = true;\r\n    function retrieveValue() {\r\n        let rpcEnabled = self.ctx.defaultSubscription.rpcEnabled;\r\n        let isSimulated = self.ctx.$scope.widgetEditMode;\r\n        if (!rpcEnabled) {\r\n            self.ctx.$scope.error = 'Target device is not set!';\r\n        } else {\r\n            if (!isSimulated) {\r\n                if (settings.retrieveMethod == 'rpc') {\r\n                    rpcRetrieveValue(settings.retrieveRPCMethod, settings.requestTimeout);\r\n                } else if (settings.retrieveMethod == 'attribute' || settings.retrieveMethod == 'timeseries') {\r\n                    if (firstRetrieveValue) {\r\n                        subscribeAttributesOrTimeseries(\"entity\", // types.datasourceType.entity, in types.constant.js\r\n                            \"DEVICE\", //types.entityType.device, in types.constant.js\r\n                            self.ctx.defaultSubscription.targetDeviceId, \r\n                            settings.retrieveMethod, \r\n                            settings.retrieveAttributeKey);\r\n                    }\r\n                }\r\n            } \r\n        }\r\n        \r\n        firstRetrieveValue = false;\r\n    }\r\n    \r\n    retrieveValue();\r\n};\r\n\r\nself.onResize = function() {\r\n};\r\n\r\nself.onDestory = function() {\r\n    if (valueSubscription) {\r\n        self.ctx.subscriptionApi.removeSubscription(valueSubscription.id);\r\n    }\r\n};\r\n\r\n/*self.onDataUpdated = function() {\r\n    try{\r\n        self.ctx.$scope.currentValue = self.ctx.$scope.originalValue = self.ctx.data[0].data[0][1];\r\n        self.ctx.$scope.$digest();\r\n    } catch (e) {\r\n        console.log(e);\r\n    }\r\n}*/\r\n\r\n/*self.typeParameters = function() {\r\n    return {\r\n        maxDatasources: 1, // Maximum allowed datasources for this widget, -1 - unlimited\r\n        maxDataKeys: 1 //Maximum allowed data keys for this widget, -1 - unlimited\r\n    }\r\n};*/\r\n",
        "settingsSchema": "{\n    \"schema\": {\n        \"type\": \"object\",\n        \"title\": \"Settings\",\n        \"properties\": {\n            \"title\": {\n                \"title\": \"Widget title\",\n                \"type\": \"string\",\n                \"default\": \"\"\n            },\n            \n            \"retrieveMethod\": {\n                \"title\": \"Retrieve timezone(integer value) using method\",\n                \"type\": \"string\",\n                \"default\": \"rpc\"\n            },\n            \"retrieveAttributeKey\": {\n                \"title\": \"Retrieve Attribute/Timeseries value key (only when subscribe for attribute/timeseries method)\",\n                \"type\": \"string\",\n                \"default\": \"\"\n            },\n            \"retrieveRPCMethod\": {\n                \"title\": \"Retrieve value using RPC method (only when call RPC get value method)\",\n                \"type\": \"string\",\n                \"default\": \"\"\n            },\n            \"parseValueFunction\": {\n                \"title\": \"Parse value function, f(data), returns timezone(integer value)\",\n                \"type\": \"string\",\n                \"default\": \"return data; /* console.log(data); */ \"\n            },\n            \n            \"updateMethod\": {\n                \"title\": \"Update timezone(integer value) using method\",\n                \"type\": \"string\",\n                \"default\": \"rpc\"\n            },\n            \"updateAttributeKey\": {\n                \"title\": \"Update Attribute/Timeseries value key (only when update for attribute/timeseries method)\",\n                \"type\": \"string\",\n                \"default\": \"\"\n            },\n            \"updateRPCMethod\": {\n                \"title\": \"Update value using RPC method (only when call RPC set value method)\",\n                \"type\": \"string\",\n                \"default\": \"\"\n            },\n            \"convertValueFunction\": {\n                \"title\": \"Convert value function, f(value), returns payload used by RPC set value method\",\n                \"type\": \"string\",\n                \"default\": \"return value; /* console.log(value); */\"\n            },\n\n            \"requestTimeout\": {\n                \"title\": \"RPC request timeout\",\n                \"type\": \"number\",\n                \"default\": 5000\n            },\n\n            \"required\": [\n                \"retrieveMethod\",\n                \"updateMethod\"\n            ]\n        }\n    },\n    \"form\": [\n        \"title\",\n\n        {\n            \"key\": \"retrieveMethod\",\n            \"type\": \"rc-select\",\n            \"multiple\": false,\n            \"items\": [\n                {\n                    \"value\": \"none\",\n                    \"label\": \"Don't retrieve\"\n                },\n                {\n                    \"value\": \"attribute\",\n                    \"label\": \"Subscribe for attribute\"\n                },\n                {\n                    \"value\": \"timeseries\",\n                    \"label\": \"Subscribe for timeseries\"\n                },\n                {\n                    \"value\": \"rpc\",\n                    \"label\": \"Call RPC get value method\"\n                }\n            ]\n        },\n        \"retrieveAttributeKey\",\n        \"retrieveRPCMethod\",\n        {\n            \"key\": \"parseValueFunction\",\n            \"type\": \"javascript\"\n        },\n        \n        {\n            \"key\": \"updateMethod\",\n            \"type\": \"rc-select\",\n            \"multiple\": false,\n            \"items\": [\n                {\n                    \"value\": \"SHARED_SCOPE\",\n                    \"label\": \"Update shared attribute\"\n                },\n                {\n                    \"value\": \"SERVER_SCOPE\",\n                    \"label\": \"Update server attribute\"\n                },\n                {\n                    \"value\": \"timeseries\",\n                    \"label\": \"Update timeseries\"\n                },\n                {\n                    \"value\": \"rpc\",\n                    \"label\": \"Call RPC set value method\"\n                }\n            ]\n        },\n        \"updateAttributeKey\",\n        \"updateRPCMethod\",\n        {\n            \"key\": \"convertValueFunction\",\n            \"type\": \"javascript\"\n        },\n        \n        \"requestTimeout\"\n    ]\n}",
        "dataKeySettingsSchema": "{}\r\n",
        "defaultConfig": "{\"showTitle\":true,\"backgroundColor\":\"#e6e7e8\",\"color\":\"rgba(0, 0, 0, 0.87)\",\"padding\":\"8px\",\"settings\":{\"optionStyle\":{\"orientation\":\"column\",\"isRaised\":true,\"checkedOption\":{\"isPrimary\":true},\"uncheckedOption\":{\"isPrimary\":false}},\"options\":[{\"optionLabel\":\"Option1 Label\",\"attributeValue\":\"option1\"},{\"optionLabel\":\"Option2 Label\",\"attributeValue\":\"option2\"}],\"retrieveMethod\":\"rpc\",\"retrieveAttributeKey\":\"value\",\"retrieveRPCMethod\":\"getValue\",\"parseValueFunction\":\"/* console.log(data); */\\nreturn data;\",\"updateMethod\":\"rpc\",\"updateAttributeKey\":\"value\",\"updateRPCMethod\":\"setValue\",\"convertValueFunction\":\"/* console.log(value); */\\nreturn value;\",\"requestTimeout\":5000},\"title\":\"Select timezone value\",\"showTitleIcon\":false,\"titleIcon\":\"more_horiz\",\"iconColor\":\"rgba(0, 0, 0, 0.87)\",\"iconSize\":\"24px\",\"titleTooltip\":\"\",\"dropShadow\":true,\"enableFullscreen\":false,\"widgetStyle\":{},\"titleStyle\":{\"fontSize\":\"16px\",\"fontWeight\":400},\"useDashboardTimewindow\":true,\"displayTimewindow\":true,\"showLegend\":false,\"actions\":{},\"targetDeviceAliases\":[]}"
      }
    },
    {
      "alias": "update_time_value",
      "name": "Update time value",
      "descriptor": {
        "type": "rpc",
        "sizeX": 3.5,
        "sizeY": 3.5,
        "resources": [],
        "templateHtml": "<div tb-toast toastTarget=\"{{ toastTargetId }}\" style=\"width: 100%; height: 100%;\">\r\n    <form class=\"attribute-update-form\"\r\n          name=\"attrUpdateForm\"\r\n          (ngSubmit)=\"updateValue()\">\r\n          <div style=\"padding: 0 2px; margin: auto 0;\">\r\n            <div class=\"attribute-update-form__grid\" [fxShow]=\"entityDetected && isValidParameter && dataKeyDetected\" style=\"height: 26px;\">\r\n                <div class=\"grid__element\" style=\"horizontal-alignment:false; width: 50px;\">\r\n                    <mat-form-field class=\"mat-block\" style=\"width: 100%; height: 26px;\">\r\n\t\t\t\t\t    <input mat-timepicker matInput \r\n                               [(ngModel)]=\"currentValue\"\r\n                               required\r\n                               type=\"time\"\r\n\t\t\t\t\t\t\t   [ngModelOptions]=\"{standalone: true}\" />\r\n                        <mat-error>\r\n                            {{requiredErrorMessage}}\r\n                        </mat-error>\r\n                    </mat-form-field>\r\n                </div>\r\n\r\n                <div class=\"grid__element\" style=\"align-items:center; margin-top: 6px;\">\r\n                    <button mat-button mat-icon-button class=\"applyChanges\"\r\n                               type=\"submit\"\r\n                               [disabled]=\"(originalValue === currentValue) || (!currentValue)\"\r\n                               matTooltip=\"{{ 'widgets.input-widgets.update-attribute' | translate }}\"\r\n                               matTooltipPosition=\"above\">\r\n                        <mat-icon>check</mat-icon>\r\n                    </button>\r\n                    <button mat-button mat-icon-button class=\"discardChanges\"\r\n                               type=\"button\"\r\n                               [disabled]=\"originalValue === currentValue\"\r\n                               (click)=\"currentValue = originalValue;\"\r\n                               matTooltip=\"{{ 'widgets.input-widgets.discard-changes' | translate }}\"\r\n                               matTooltipPosition=\"above\">\r\n                        <mat-icon>close</mat-icon>\r\n                    </button>\r\n                </div>\r\n            </div>\r\n    \r\n            <div style=\"text-align: center; font-size: 18px; color: #a0a0a0;\" [fxHide]=\"entityDetected\" [innerHtml]=\"message\"></div>\r\n            <div style=\"text-align: center; font-size: 18px; color: #a0a0a0;\"\r\n                 [fxShow]=\"entityDetected && !dataKeyDetected\">\r\n                {{ 'widgets.input-widgets.no-attribute-selected' | translate }}\r\n            </div>\r\n            <div style=\"text-align: center; font-size: 18px; color: #a0a0a0;\"\r\n                 [fxShow]=\"entityDetected && !isValidParameter\">\r\n                {{ 'widgets.input-widgets.timeseries-not-allowed' | translate }}\r\n            </div>\r\n        </div>\r\n    </form>\r\n</div>\r\n",
        "templateCss": ".attribute-update-form {\r\n    overflow: hidden;\r\n    height: 100%;\r\n    display: flex;\r\n    flex-direction: column;\r\n}\r\n\r\n.entity-title {\r\n    font-weight: bold;\r\n    font-size: 22px;\r\n    padding-top: 12px;\r\n    padding-bottom: 6px;\r\n    color: #666;\r\n}\r\n\r\n.attribute-update-form__grid {\r\n    display: flex;\r\n}\r\n.grid__element:first-child {\r\n    flex-direction: column;\r\n    flex: 1;\r\n}\r\n.grid__element.horizontal-alignment {\r\n    flex-direction: row;\r\n}\r\n.grid__element:last-child {\r\n    align-items: center;\r\n    margin-left: 2px;\r\n}\r\n.grid__element {\r\n    display: flex;\r\n}\r\n\r\n.attribute-update-form .mat-button.mat-icon-button {\r\n    margin: 0;\r\n    width: 24px;\r\n    min-width: 24px;\r\n    height: 24px;\r\n    min-height: 24px;\r\n    padding: 0 !important;\r\n    margin: 0 !important;\r\n    line-height: 20px;\r\n}\r\n\r\n.attribute-update-form .mat-icon-button mat-icon {\r\n    width: 20px;\r\n    min-width: 20px;\r\n    height: 20px;\r\n    min-height: 20px;\r\n    font-size: 20px;\r\n}\r\n\r\n.attribute-update-form mdp-date-picker,\r\n.attribute-update-form mdp-time-picker {\r\n    width: 100%;\r\n}\r\n\r\n.attribute-update-form mdp-date-picker md-input-container,\r\n.attribute-update-form mdp-time-picker md-input-container {\r\n    margin: 5px 0 5px;\r\n    width: 100%;\r\n}\r\n\r\n.attribute-update-form grid__element .button.mat-icon-button {\r\n    margin: 2px 0 0;\r\n    padding: 0;\r\n    width: 22px;\r\n    height: 20px;\r\n}\r\n\r\n.attribute-update-form mat-form-field .mat-form-field-infix {\r\n    padding: 0;\r\n    border-top: .6em solid transparent;\r\n}\r\n\r\n.attribute-update-form.small-width mdp-date-picker md-input-container,\r\n.attribute-update-form.small-width mdp-time-picker md-input-container {\r\n    width: 78px;\r\n}\r\n\r\n.show-label label {\r\n    display: block;\r\n}\r\n\r\nlabel {\r\n    display: none;\r\n}\r\n\r\nmd-toast{\r\n    min-width: 0;\r\n}\r\n.tb-toast {\r\n    font-size: 14px!important;\r\n}\r\n",
        "controllerScript": "// placeholder=\"{{ 'widgets.input-widgets.time' | translate }}\"\r\n\r\nlet valueSubscription;\r\nlet $scope;\r\n\r\nself.onInit = function() {\r\n    //console.log(\"self.onInit()\");\r\n    self.ctx.ngZone.run(function() {\r\n       init();\r\n       self.ctx.detectChanges(true);\r\n    });\r\n};\r\n\r\n\r\nfunction init() {\r\n\r\n    $scope = self.ctx.$scope;\r\n    let utils       = self.ctx.$scope.$injector.get(self.ctx.servicesMap.get('utils'));\r\n    //let types       = self.ctx.$scope.$injector.get(self.ctx.servicesMap.get('types'));\r\n    //let toast       = self.ctx.$scope.$injector.get(self.ctx.servicesMap.get('toast'));\r\n    let translate   = self.ctx.$scope.$injector.get(self.ctx.servicesMap.get('translate'));\r\n    //let $q          = self.ctx.$scope.$injector.get(self.ctx.servicesMap.get('$q'));\r\n    let http        = self.ctx.$scope.$injector.get(self.ctx.servicesMap.get('http'));\r\n    let attributeService = self.ctx.$scope.$injector.get(self.ctx.servicesMap.get('attributeService'));\r\n    let rpcUpdateStatus = {};\r\n    let settings = utils.deepClone(self.ctx.settings) || {};\r\n    self.ctx.$scope.toastTargetId = 'input-widget' + utils.guid();\r\n    $scope.settings = settings;\r\n    $scope.isValidParameter = true;                 // yes,html\r\n    $scope.entityDetected = true;       // false;   // yes,html\r\n    $scope.dataKeyDetected = true;      // false;   // yes,html\r\n    $scope.message = translate.instant('widgets.input-widgets.no-entity-selected');    // yes,html\r\n    $scope.requiredErrorMessage = utils.customTranslation(settings.requiredErrorMessage, settings.requiredErrorMessage) || translate.instant            ('widgets.input-widgets.entity-attribute-required');    // yes,html\r\n    if (settings.widgetTitle && settings.widgetTitle.length) {\r\n        $scope.titleTemplate = utils.customTranslation(settings.widgetTitle, settings.widgetTitle);\r\n    } else {\r\n        $scope.titleTemplate = self.ctx.widgetConfig.title;\r\n    }\r\n    //self.ctx.widgetTitle = utils.createLabelFromDatasource(self.ctx.datasources[0], $scope.titleTemplate);\r\n    self.ctx.widgetTitle = $scope.titleTemplate;\r\n\r\n    ////self.ctx.$scope.showTitle = self.ctx.settings.title && self.ctx.settings.title.length ? true : false;\r\n    ////self.ctx.$scope.title = self.ctx.settings.title;\r\n    \r\n    /*function parseValue(data) {\r\n        //Using retrieve data: parse \"09:30\" to \"Thu Jan 01 1970 09:30:00 GMT+0800 ()\"\r\n        let result;\r\n        if (data && data.length>1 && typeof data === \"string\") {\r\n            var strarr = data.split(':', 3);\r\n            if (strarr && strarr.length>=2) {\r\n                var hour = Number(strarr[0]);\r\n                var min = Number(strarr[1]);\r\n                \r\n                if (hour>=0 && hour<=23 && min>=0 && min<=59) {\r\n                    var m = moment(\"1970-01-01 00:00:00.000\")\r\n                    m.hour(hour); \r\n                    m.minute(min); \r\n                    if (m.isValid()) {\r\n                        result = m.toDate();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        \r\n        console.log(\"parseValue(): \", data, result);\r\n        return result;\r\n    }*/\r\n    let parseValueFunction = (data) => data; //parseValue;  // Retrieve data\r\n    if (settings.parseValueFunction && settings.parseValueFunction.length) { \r\n        try {\r\n            parseValueFunction = new Function('data', settings.parseValueFunction);\r\n        } catch (e) {\r\n            parseValueFunction = (data) => data; //parseValue;\r\n        }\r\n    }\r\n\r\n    /*function prefixInteger(num, n) {\r\n        return (Array(n).join(0) + num).slice(-n);\r\n    }    \r\n    function convertValue(value) {\r\n        // Using update data: convert 'Thu Jan 01 1970 09:30:00 GMT+0800 ()' to \"09:30\"\r\n        let result;\r\n        var m = moment(value);\r\n        if (m.isValid()) {\r\n            //result = prefixInteger(m.hour(), 2) + \":\" +prefixInteger(m.minute(), 2);\r\n            result = (Array(2).join(0) + m.hour()).slice(-2) + \":\" +(Array(2).join(0) + m.minute()).slice(-2);\r\n        }\r\n        return result;\r\n    }*/\r\n    let convertValueFunction = (value) => value; //convertValue;    // Update data\r\n    if (settings.convertValueFunction && settings.convertValueFunction.length) {\r\n        try {\r\n            convertValueFunction = new Function('value', settings.convertValueFunction);\r\n        } catch (e) {\r\n            convertValueFunction = (value) => value; //convertValue;\r\n        }\r\n    }\r\n\r\n    // subscribe attribute & timeseries\r\n    function onDataUpdatedForSubscribe(subscription, apply) {\r\n        if (subscription.data.length) {\r\n            var keyData = subscription.data[0];\r\n            if (keyData && keyData.data && keyData.data[0]) {\r\n                var attrValue = keyData.data[0][1];\r\n                if (attrValue) {\r\n                    try {\r\n                        self.ctx.$scope.currentValue = self.ctx.$scope.originalValue = parseValueFunction(attrValue);  ////angular.fromJson(attrValue)\r\n                    } catch (e){\r\n                        //self.ctx.$scope.error = 'parseValueFunction(value) error!'\r\n\t\t\t$scope.showErrorToast(translate.instant(e), 'bottom', 'left', $scope.toastTargetId);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        \r\n        if (apply) {\r\n            self.ctx.detectChanges(); //self.ctx.$scope.$digest();\r\n        }\r\n    }\r\n    function onDataUpdateErrorForSubscribe(subscription, e) {\r\n        var exceptionData = utils.parseException(e);\r\n        var errorText = exceptionData.name;\r\n        if (exceptionData.message) {\r\n            errorText += ': ' + exceptionData.message;\r\n        }\r\n        self.ctx.$scope.error = errorText;\r\n    }\r\n    function subscribeAttributesOrTimeseries(type, entityType, entityId, retrieveMethod, key) {\r\n        var valueSubscriptionInfo = [{\r\n            type:       type,\r\n            entityType: entityType,\r\n            entityId:   entityId\r\n        }];\r\n        \r\n        if (retrieveMethod == 'attribute') {\r\n            valueSubscriptionInfo[0].attributes = [\r\n                {name: key}\r\n            ];\r\n        } else {\r\n            valueSubscriptionInfo[0].timeseries = [\r\n                {name: key}\r\n            ];\r\n        }\r\n        \r\n        var subscriptionOptions = {\r\n            callbacks: {\r\n                onDataUpdated: onDataUpdatedForSubscribe,\r\n                onDataUpdateError: onDataUpdateErrorForSubscribe\r\n            }\r\n        };\r\n        self.ctx.subscriptionApi.createSubscriptionFromInfo (\r\n            'latest', valueSubscriptionInfo, subscriptionOptions, false, true).subscribe( //types.widgetType.latest.value\r\n            (subscription) => {\r\n                valueSubscription = subscription;\r\n            }\r\n        );    \r\n    }\r\n    \r\n    // update attribute\r\n    function updateAttributes(entityType, entityId, attributeScope, key, value) {\r\n        let attributes = [];\r\n        attributes.push({\r\n            \"key\": key,         // attribute name,\r\n            \"value\": value      // attribute value\r\n        });\r\n\r\n        ////attributeService.saveEntityAttributes(self.ctx.datasources[0].entityType, self.ctx.datasources[0].entityId,\r\n        attributeService.saveEntityAttributes({\"entityType\":entityType, \"id\":entityId}, \r\n            attributeScope, attributes).subscribe(\r\n            function success() {\r\n                ////self.ctx.$scope.error = \"\";\r\n                if (settings.showResultMessage) {\r\n                        $scope.showSuccessToast(translate.instant('widgets.input-widgets.update-successful'), 1000, 'bottom', 'left', $scope.toastTargetId);\r\n                }\r\n                retrieveValue();  //self.ctx.$scope.originalValue = self.ctx.$scope.currentValue = value;\r\n            },\r\n            function fail(rejection) {\r\n                ////if (self.ctx.settings.showError) {\r\n                ////    self.ctx.$scope.error = rejection.status + \": \" + rejection.statusText;\r\n                ////}\r\n                if (settings.showResultMessage) {\r\n                        $scope.showErrorToast(translate.instant('widgets.input-widgets.update-failed'), 'bottom', 'left', $scope.toastTargetId);\r\n                }\r\n            }\r\n        );\r\n    }\r\n    \r\n    // update timeseries \r\n    function saveEntityTimeseries(entityType, entityId, telemetries) {\r\n        var telemetriesData = {};\r\n        for (var a = 0; a < telemetries.length; a++) {\r\n            if (typeof telemetries[a].value !== 'undefined' && telemetries[a].value !== null) {\r\n                telemetriesData[telemetries[a].key] = telemetries[a].value;\r\n            }\r\n        }\r\n        if (Object.keys(telemetriesData).length) {\r\n            var url = '/api/plugins/telemetry/' + entityType + '/' + entityId + '/timeseries/scope';\r\n            return http.post(url, telemetriesData);\r\n        }\r\n        return null;\r\n    }\r\n    function updateTimeseries(entityType, entityId, key, value) {\r\n        //var datasource = self.ctx.datasources[0];\r\n        let observable = saveEntityTimeseries(\r\n            entityType,     // datasource.entityType,\r\n            entityId,       // datasource.entityId,\r\n            [\r\n                {\r\n                    key: key,\r\n                    value: value\r\n                }\r\n            ]\r\n        );\r\n        if (observable) {\r\n            observable.subscribe(\r\n                function success() {\r\n                    ////self.ctx.$scope.error = \"\";\r\n                    if (settings.showResultMessage) {\r\n                        $scope.showSuccessToast(translate.instant('widgets.input-widgets.update-successful'), 1000, 'bottom', 'left', $scope.toastTargetId);\r\n                    }\r\n                    retrieveValue();    //self.ctx.$scope.originalValue = self.ctx.$scope.currentValue = value;\r\n                },\r\n                function fail() {\r\n                    ////if (self.ctx.settings.showError)\r\n                    ////    self.ctx.$scope.error = $translate.instant('widgets.input-widgets.update-failed');\r\n                    ////}\r\n                    if (settings.showResultMessage) {\r\n                        $scope.showErrorToast(translate.instant('widgets.input-widgets.update-failed'), 'bottom', 'left', $scope.toastTargetId);\r\n                    }\r\n                }\r\n            );\r\n        }\r\n    }\r\n\r\n    // RPC retrieve value\r\n    function rpcRetrieveValue(method, timeout) {\r\n        if (method && method.length) {\r\n            self.ctx.$scope.error = '';\r\n            self.ctx.controlApi.sendTwoWayCommand(method, null, timeout).subscribe(\r\n                function success(responseBody) {\r\n                    try {\r\n                        self.ctx.$scope.currentValue = self.ctx.$scope.originalValue = parseValueFunction(responseBody);\r\n                        ////self.ctx.$scope.$digest(); // Error: $digest already in progress\r\n                    } catch (e){\r\n                        //self.ctx.$scope.error = 'parseValueFunction(value) error!'\r\n\t\t\t$scope.showErrorToast(translate.instant(e), 'bottom', 'left', $scope.toastTargetId);\r\n                    }\r\n                },\r\n                function fail() {\r\n                    ////self.ctx.$scope.error = self.ctx.defaultSubscription.rpcErrorText;\r\n\t\t    $scope.showErrorToast(translate.instant(self.ctx.defaultSubscription.rpcErrorText), 'bottom', 'left', $scope.toastTargetId);\r\n                }\r\n            );\r\n        } else {\r\n            ////self.ctx.$scope.error = \"retrieveRPCMethod is null.\";\r\n\t    $scope.showErrorToast(translate.instant('retrieveRPCMethod is null.'), 'bottom', 'left', $scope.toastTargetId);\r\n        }\r\n    }\r\n    // RPC update value\r\n    function rpcUpdateValue(method, value, timeout) {\r\n        if (rpcUpdateStatus.executingUpdateValue) {\r\n            rpcUpdateStatus.scheduledValue = value;\r\n            return;\r\n        } else {\r\n            rpcUpdateStatus.scheduledValue = null;\r\n            rpcUpdateStatus.rpcValue = value;\r\n            rpcUpdateStatus.executingUpdateValue = true;\r\n        }\r\n        self.ctx.$scope.error = '';\r\n        self.ctx.controlApi.sendOneWayCommand(method, value, timeout).subscribe(\r\n            () => {\r\n                rpcUpdateStatus.executingUpdateValue = false;\r\n                if (rpcUpdateStatus.scheduledValue !== null && rpcUpdateStatus.scheduledValue != rpcUpdateStatus.rpcValue) {\r\n                    rpcUpdateValue(rpcUpdateStatus.scheduledValue);\r\n                } else {\r\n                    ////self.ctx.$scope.error = \"\";\r\n                    if (settings.showResultMessage) {\r\n\t\t\t$scope.showSuccessToast(translate.instant('widgets.input-widgets.update-successful'), 1000, 'bottom', 'left', $scope.toastTargetId);\r\n                    }\r\n                    retrieveValue(); // self.ctx.$scope.originalValue = self.ctx.$scope.currentValue = value;\r\n                }\r\n            },\r\n            () => {\r\n                rpcUpdateStatus.executingUpdateValue = false;\r\n                ////if (self.ctx.settings.showError) {\r\n                ////    self.ctx.$scope.error = self.ctx.defaultSubscription.rpcErrorText;\r\n                ////}\r\n                if (settings.showResultMessage) {\r\n\t\t    $scope.showErrorToast(translate.instant('widgets.input-widgets.update-failed'), 'bottom', 'left', $scope.toastTargetId);\r\n                }\r\n            }\r\n        );\r\n    }\r\n\r\n    // update value\r\n\r\n    self.ctx.$scope.updateValue = function(option) {\r\n        var newValue = convertValueFunction($scope.currentValue);\r\n        //console.log(\"updateValue():\", newValue);\r\n        \r\n        if (newValue && newValue.length){\r\n            if (settings.updateMethod === \"SHARED_SCOPE\" || settings.updateMethod === \"SERVER_SCOPE\") {\r\n                updateAttributes(\"DEVICE\", //types.entityType.device, \r\n                    self.ctx.defaultSubscription.targetDeviceId, \r\n                    settings.updateMethod, \r\n                    settings.updateAttributeKey, \r\n                    newValue);\r\n                    \r\n            } else if (settings.updateMethod === \"timeseries\") {\r\n                updateTimeseries(\"DEVICE\", // types.entityType.device,  types.constant.js\r\n                    self.ctx.defaultSubscription.targetDeviceId, \r\n                    settings.updateAttributeKey, \r\n                    newValue);\r\n                    \r\n            } else if (settings.updateMethod === \"rpc\") {\r\n                rpcUpdateValue(settings.updateRPCMethod, \r\n                    newValue, \r\n                    settings.requestTimeout);\r\n                \r\n            } else {\r\n                self.ctx.$scope.error = \"updateMethod is error!\";\r\n    \r\n            }\r\n        }\r\n    }\r\n\r\n    // retrieve value\r\n    var firstRetrieveValue = true;\r\n    function retrieveValue() {\r\n        let rpcEnabled = self.ctx.defaultSubscription.rpcEnabled;\r\n        let isSimulated = self.ctx.$scope.widgetEditMode;\r\n        if (!rpcEnabled) {\r\n            self.ctx.$scope.error = 'Target device is not set!';\r\n        } else {\r\n            if (!isSimulated) {\r\n                if (settings.retrieveMethod == 'rpc') {\r\n                    rpcRetrieveValue(settings.retrieveRPCMethod, settings.requestTimeout);\r\n                } else if (settings.retrieveMethod == 'attribute' || settings.retrieveMethod == 'timeseries') {\r\n                    if (firstRetrieveValue) {\r\n                        subscribeAttributesOrTimeseries(\"entity\", // types.datasourceType.entity, in types.constant.js\r\n                            \"DEVICE\", //types.entityType.device, in types.constant.js\r\n                            self.ctx.defaultSubscription.targetDeviceId, \r\n                            settings.retrieveMethod, \r\n                            settings.retrieveAttributeKey);\r\n                    }\r\n                }\r\n            } \r\n        }\r\n        \r\n        firstRetrieveValue = false;\r\n    }\r\n    \r\n    retrieveValue();\r\n};\r\n\r\nself.onResize = function() {\r\n    $scope.smallWidthContainer = (self.ctx.$container[0].offsetWidth < 320) ? true : false;\r\n    $scope.changeAlignment = false;\r\n};\r\n\r\nself.onDestory = function() {\r\n    if (valueSubscription) {\r\n        self.ctx.subscriptionApi.removeSubscription(valueSubscription.id);\r\n    }\r\n};\r\n\r\n/*self.onDataUpdated = function() {\r\n    try{\r\n        self.ctx.$scope.currentValue = self.ctx.$scope.originalValue = self.ctx.data[0].data[0][1];\r\n        self.ctx.$scope.$digest();\r\n    } catch (e) {\r\n        console.log(e);\r\n    }\r\n}*/\r\n\r\n/*self.typeParameters = function() {\r\n    return {\r\n        maxDatasources: 1, // Maximum allowed datasources for this widget, -1 - unlimited\r\n        maxDataKeys: 1 //Maximum allowed data keys for this widget, -1 - unlimited\r\n    }\r\n};*/\r\n",
        "settingsSchema": "{\r\n    \"schema\": {\r\n        \"type\": \"object\",\r\n        \"title\": \"Settings\",\r\n        \"properties\": {\r\n            \"title\": {\r\n                \"title\": \"Widget title\",\r\n                \"type\": \"string\",\r\n                \"default\": \"\"\r\n            },\r\n            \r\n            \"retrieveMethod\": {\r\n                \"title\": \"Retrieve string value using method\",\r\n                \"type\": \"string\",\r\n                \"default\": \"rpc\"\r\n            },\r\n            \"retrieveAttributeKey\": {\r\n                \"title\": \"Retrieve Attribute/Timeseries value key (only when subscribe for attribute/timeseries method)\",\r\n                \"type\": \"string\",\r\n                \"default\": \"\"\r\n            },\r\n            \"retrieveRPCMethod\": {\r\n                \"title\": \"Retrieve value using RPC method (only when call RPC get value method)\",\r\n                \"type\": \"string\",\r\n                \"default\": \"\"\r\n            },\r\n            \"parseValueFunction\": {\r\n                \"title\": \"Parse value function, f(data), returns string\",\r\n                \"type\": \"string\",\r\n                \"default\": \"\"\r\n            },\r\n            \r\n            \"updateMethod\": {\r\n                \"title\": \"Update string value using method\",\r\n                \"type\": \"string\",\r\n                \"default\": \"rpc\"\r\n            },\r\n            \"updateAttributeKey\": {\r\n                \"title\": \"Update Attribute/Timeseries value key (only when update for attribute/timeseries method)\",\r\n                \"type\": \"string\",\r\n                \"default\": \"\"\r\n            },\r\n            \"updateRPCMethod\": {\r\n                \"title\": \"Update value using RPC method (only when call RPC set value method)\",\r\n                \"type\": \"string\",\r\n                \"default\": \"\"\r\n            },\r\n            \"convertValueFunction\": {\r\n                \"title\": \"Convert value function, f(value), returns payload used by RPC set value method\",\r\n                \"type\": \"string\",\r\n                \"default\": \"\"\r\n            },\r\n\r\n            \"requestTimeout\": {\r\n                \"title\": \"RPC request timeout\",\r\n                \"type\": \"number\",\r\n                \"default\": 5000\r\n            },\r\n            \r\n            \"showResultMessage\":{\r\n                \"title\":\"Show result message\",\r\n                \"type\":\"boolean\",\r\n                \"default\":true\r\n            },\r\n            \"requiredErrorMessage\": {\r\n                \"title\": \"'Required' error message\",\r\n                \"type\": \"string\",\r\n                \"default\": \"\"\r\n            }\r\n        },\r\n        \"required\": [\r\n            \"retrieveMethod\",\r\n            \"updateMethod\"\r\n        ]\r\n    },\r\n    \"form\": [\r\n        \"title\",\r\n\r\n        {\r\n            \"key\": \"retrieveMethod\",\r\n            \"type\": \"rc-select\",\r\n            \"multiple\": false,\r\n            \"items\": [\r\n                {\r\n                    \"value\": \"none\",\r\n                    \"label\": \"Don't retrieve\"\r\n                },\r\n                {\r\n                    \"value\": \"attribute\",\r\n                    \"label\": \"Subscribe for attribute\"\r\n                },\r\n                {\r\n                    \"value\": \"timeseries\",\r\n                    \"label\": \"Subscribe for timeseries\"\r\n                },\r\n                {\r\n                    \"value\": \"rpc\",\r\n                    \"label\": \"Call RPC get value method\"\r\n                }\r\n            ]\r\n        },\r\n        \"retrieveAttributeKey\",\r\n        \"retrieveRPCMethod\",\r\n        {\r\n            \"key\": \"parseValueFunction\",\r\n            \"type\": \"javascript\"\r\n        },\r\n        \r\n        {\r\n            \"key\": \"updateMethod\",\r\n            \"type\": \"rc-select\",\r\n            \"multiple\": false,\r\n            \"items\": [\r\n                {\r\n                    \"value\": \"SHARED_SCOPE\",\r\n                    \"label\": \"Update shared attribute\"\r\n                },\r\n                {\r\n                    \"value\": \"SERVER_SCOPE\",\r\n                    \"label\": \"Update server attribute\"\r\n                },\r\n                {\r\n                    \"value\": \"timeseries\",\r\n                    \"label\": \"Update timeseries\"\r\n                },\r\n                {\r\n                    \"value\": \"rpc\",\r\n                    \"label\": \"Call RPC set value method\"\r\n                }\r\n            ]\r\n        },\r\n        \"updateAttributeKey\",\r\n        \"updateRPCMethod\",\r\n        {\r\n            \"key\": \"convertValueFunction\",\r\n            \"type\": \"javascript\"\r\n        },\r\n        \r\n        \"requestTimeout\",\r\n        \r\n        \"showResultMessage\",\r\n        \"requiredErrorMessage\"\r\n    ]\r\n}\r\n",
        "dataKeySettingsSchema": "{}\r\n",
        "defaultConfig": "{\"showTitle\":true,\"backgroundColor\":\"#ffffff\",\"color\":\"rgba(0, 0, 0, 0.87)\",\"padding\":\"8px\",\"settings\":{\"retrieveMethod\":\"rpc\",\"retrieveAttributeKey\":\"value\",\"retrieveRPCMethod\":\"getValue\",\"updateMethod\":\"rpc\",\"updateAttributeKey\":\"value\",\"updateRPCMethod\":\"setValue\",\"requestTimeout\":5000,\"showResultMessage\":true},\"title\":\"Update time value\",\"showTitleIcon\":false,\"titleIcon\":\"more_horiz\",\"iconColor\":\"rgba(0, 0, 0, 0.87)\",\"iconSize\":\"24px\",\"titleTooltip\":\"\",\"dropShadow\":true,\"enableFullscreen\":false,\"widgetStyle\":{},\"titleStyle\":{\"fontSize\":\"16px\",\"fontWeight\":400},\"useDashboardTimewindow\":true,\"displayTimewindow\":true,\"showLegend\":false,\"actions\":{},\"targetDeviceAliases\":[]}"
      }
    },
    {
      "alias": "rtc_button_with_method_params",
      "name": "RTC button with params & response",
      "descriptor": {
        "type": "rpc",
        "sizeX": 7,
        "sizeY": 4,
        "resources": [],
        "templateHtml": "    <form #rpcForm=\"ngForm\" (submit)=\"sendCommand()\">\r\n      <div class=\"mat-content mat-padding\" fxLayout=\"column\">\r\n        <mat-form-field [fxShow]=\"requireParam\" class=\"mat-block\">\r\n          <mat-label>{{ paramLabel }}</mat-label>  \r\n          <input matInput required name=\"rpcParams\" #rpcParamsField=\"ngModel\" [(ngModel)]=\"rpcParams\"/>\r\n          <mat-error *ngIf=\"rpcParamsField.hasError('required')\">\r\n            RPC params is required.\r\n          </mat-error>\r\n        </mat-form-field>\r\n        <button [disabled]=\"requireParam && (rpcForm.invalid || !rpcForm.dirty)\" mat-raised-button color=\"primary\"  type=\"submit\" >\r\n            {{ buttonLabel }}\r\n        </button>\r\n        <div style=\"margin-top: 18px;\">\r\n          <label>RPC command response</label>\r\n          <div style=\"width: 100%; height: 60px; border: solid 2px gray\" [innerHTML]=\"rpcCommandResponse\">\r\n          </div>\r\n        </div>\r\n      </div>\r\n    </form>\r\n",
        "templateCss": "\n",
        "controllerScript": "self.onInit = function() {\r\n    let utils    = self.ctx.$scope.$injector.get(self.ctx.servicesMap.get('utils'));\r\n    let settings = utils.deepClone(self.ctx.settings) || {}; \r\n    \r\n    self.ctx.$scope.requireParam  = settings.requireParam;\r\n    self.ctx.$scope.paramLabel  = settings.paramLabel;\r\n    self.ctx.$scope.buttonLabel = settings.buttonLabel;\r\n    \r\n    self.ctx.$scope.sendCommand = function() {\r\n        //var rpcMethod = self.ctx.$scope.rpcMethod;\r\n        var rpcMethod = self.ctx.settings.rpcMethod;\r\n        var rpcParams = self.ctx.$scope.rpcParams;\r\n        var timeout = self.ctx.settings.requestTimeout;\r\n        var oneWayElseTwoWay = self.ctx.settings.oneWayElseTwoWay ? true : false;\r\n        \r\n        //console.log(\"sendCommand()\");\r\n        //console.log(rpcMethod);\r\n        //console.log(rpcParams);\r\n        //console.log(timeout);\r\n        //console.log(oneWayElseTwoWay);\r\n        \r\n        var commandObservable;\r\n        if (oneWayElseTwoWay) {\r\n            commandObservable = self.ctx.controlApi.sendOneWayCommand(rpcMethod, rpcParams, timeout);\r\n        } else {\r\n            commandObservable = self.ctx.controlApi.sendTwoWayCommand(rpcMethod, rpcParams, timeout);\r\n        }\r\n        commandObservable.subscribe(\r\n            function (response) {\r\n                if (oneWayElseTwoWay) {\r\n                    self.ctx.$scope.rpcCommandResponse = \"Command was successfully received by device.<br> No response body because of one way command mode.\";\r\n                } else {\r\n                    self.ctx.$scope.rpcCommandResponse = \"Response from device:<br>\";                    \r\n                    self.ctx.$scope.rpcCommandResponse += JSON.stringify(response, undefined, 2);\r\n                }\r\n                self.ctx.detectChanges();\r\n            },\r\n            function (rejection) {\r\n                self.ctx.$scope.rpcCommandResponse = \"Failed to send command to the device:<br>\"\r\n                self.ctx.$scope.rpcCommandResponse += \"Status: \" + rejection.status + \"<br>\";\r\n                self.ctx.$scope.rpcCommandResponse += \"Status text: '\" + rejection.statusText + \"'\";\r\n                self.ctx.detectChanges();\r\n            }\r\n            \r\n        );\r\n    }\r\n    \r\n}\r\n\r\n\r\n/* \r\n        <mat-form-field class=\"mat-block\">\r\n          <mat-label>RPC method</mat-label>\r\n          <input matInput required name=\"rpcMethod\" #rpcMethodField=\"ngModel\" [(ngModel)]=\"rpcMethod\"/>\r\n          <mat-error *ngIf=\"rpcMethodField.hasError('required')\">\r\n            RPC method name is required.\r\n          </mat-error>\r\n        </mat-form-field>\r\n*/\r\n",
        "settingsSchema": "{\r\n    \"schema\": {\r\n        \"type\": \"object\",\r\n        \"title\": \"Settings\",\r\n        \"properties\": {\r\n            \"rpcMethod\": {\r\n                \"title\": \"RPC method\",\r\n                \"type\": \"string\",\r\n                \"default\": \"rpcMethod\"\r\n            },\r\n            \"oneWayElseTwoWay\": {\r\n                \"title\": \"Is One Way Command\",\r\n                \"type\": \"boolean\",\r\n                \"default\": true\r\n            },\r\n            \"requestTimeout\": {\r\n                \"title\": \"RPC request timeout\",\r\n                \"type\": \"number\",\r\n                \"default\": 5000\r\n            },\r\n            \"requireParam\": {\r\n                \"title\": \"Is RPC param required\",\r\n                \"type\": \"boolean\",\r\n                \"default\": true\r\n            },\r\n            \"paramLabel\": {\r\n                \"title\": \"RPC param label\",\r\n                \"type\": \"string\",\r\n                \"default\": \"RPC param label\"\r\n            },\r\n            \"buttonLabel\": {\r\n                \"title\": \"Button label\",\r\n                \"type\": \"string\",\r\n                \"default\": \"Send RPC Command\"\r\n            }\r\n        },\r\n        \"required\": [\"rpcMethod\",\r\n            \"paramLabel\",\r\n            \"buttonLabel\"\r\n            ]\r\n    },\r\n    \"form\": [\r\n        \"rpcMethod\",\r\n        \"oneWayElseTwoWay\",\r\n        \"requestTimeout\",\r\n        \"requireParam\",\r\n        \"paramLabel\",\r\n        \"buttonLabel\"\r\n        ]\r\n} ",
        "dataKeySettingsSchema": "{}\n",
        "defaultConfig": "{\"targetDeviceAliases\":[],\"showTitle\":true,\"backgroundColor\":\"#fff\",\"color\":\"rgba(0, 0, 0, 0.87)\",\"padding\":\"0px\",\"settings\":{\"requestTimeout\":5000,\"rpcMethod\":\"rpcMethod\",\"oneWayElseTwoWay\":true,\"paramLabel\":\"RPC param label\",\"buttonLabel\":\"Send RPC Command\",\"requireParam\":true},\"title\":\"RTC button with params & response\",\"showTitleIcon\":false,\"titleIcon\":\"more_horiz\",\"iconColor\":\"rgba(0, 0, 0, 0.87)\",\"iconSize\":\"24px\",\"titleTooltip\":\"\",\"dropShadow\":true,\"enableFullscreen\":true,\"widgetStyle\":{},\"titleStyle\":{\"fontSize\":\"16px\",\"fontWeight\":400},\"useDashboardTimewindow\":true,\"displayTimewindow\":true,\"showLegend\":false,\"actions\":{}}"
      }
    }
  ]
}